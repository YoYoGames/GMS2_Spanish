<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="keywords" content="online documentation, web online help, web help, chm2web" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="generator" content="chm2web Pro 2.85 (unicode)" />
<title>The Asynchronous Events</title>
<meta http-equiv="X-UA-Compatible" content="IE=9">

<link rel="stylesheet" href="../../../../../files/helpindex.css"
type="text/css">
<link rel="stylesheet" href="../../../../../default.css" type=
"text/css">

<script type="text/JavaScript" src="../../../../../files/supply.js"></script>
<script type="text/JavaScript">
chmtop.c2wtopf.pageid = "_build/2_interface/1_editors/events/async_events.html";
</script>

</head>
<body><script type="text/JavaScript"> 
if (window.name != "content") 
  document.write(" <table width=\"100%\" bgcolor=\"#e1e1e1\"cellspacing=\"2\" cellpadding=\"0\" style=\"border-collapse: collapse; font-family: sans-serif; font-size: 14px; color: #000000; text-decoration: none;  \"> <tr> <td align=\"center\" style=\"border-bottom: 2px solid gray\" > <br>&nbsp;Click <a href=\"../../../../../index.html?page=source%2F_build%2F2_interface%2F1_editors%2Fevents%2Fasync_events.html\">here</a> to show toolbars of the Web Online Help System: <a href=\"../../../../../index.html?page=source%2F_build%2F2_interface%2F1_editors%2Fevents%2Fasync_events.html\">show toolbars</a><br>&nbsp;</td></tr></table><br> "); 
</script>
<!-- !chm2web! --><script type="text/JavaScript">
 if( typeof(chmtop.helpStyle) != 'undefined' ) { var linkNodes = document.getElementsByTagName("link");  for( var i=0; i < linkNodes.length; ++i ) { var link = linkNodes[i];    if( link.href.endsWith("default.css")) {    var style = link.href.replace("default.css", chmtop.helpStyle); document.write('<link id="newstyleLink" rel="stylesheet" href=' + style + ' type="text/css">');    break; } } } 
</script><h2> Los eventos asíncronos </h2><div class="body-scroll"><p><img class="center" src="images/editor_objects_async.png" alt="Editor de objetos Async Events"> Un <b>evento asíncrono</b> es uno que se dispara cuando <i><span class="notranslate">GameMaker Studio 2</span></i> recibe una &quot;devolución de llamada&quot; de alguna fuente externa, que puede ser desde la web o desde el dispositivo que ejecuta su juego. Básicamente, le dice a <i><span class="notranslate">GameMaker</span> Studio 2</i> que haga algo, como cargar una imagen, y comenzará a hacer esto, pero continuará haciendo lo que sea que tenga que hacer mientras funciona. Luego, cuando la solicitud se haya completado, se enviará una devolución de llamada a <i><span class="notranslate">GameMaker Studio 2</span></i> y se disparará cualquier <b>evento asíncrono</b> definido para ese tipo de devolución de llamada. Tenga en cuenta que los eventos asíncronos se activan para <i>todas las</i> instancias que los tienen, al igual que los eventos clave, por lo que puede hacer una <tt>http_get</tt> llamar en una instancia, sin embargo, tener el evento HTTP asíncrono en otro para hacer frente a la devolución de llamada. <br></p><div class="note"> <b>NOTA</b>: debe tener en cuenta que, debido a la protección de XSS en los navegadores, las solicitudes e intentos de cargar recursos de todos los dominios están bloqueados y puede parecer que devuelven resultados en blanco al usar cualquiera de los siguientes eventos </div><p><br> Hay varios tipos de eventos asociados con la categoría de eventos asíncronos, y todos se explican en las siguientes secciones: </p><div class="note"> <b>NOTA:</b> La variable <tt>async_load</tt> que se menciona en las siguientes secciones <b>solo</b> es <b>válido en estos eventos</b>, ya que el <tt>ds_map</tt> es decir, se crea un punto al comienzo del evento, y luego se elimina de nuevo al final, y esta variable se restablece a un valor de -1 en todos los demás momentos. </div><p><br></p><blockquote><a name="async_audio_play" id="async_audio_play"></a> <label class="collapse" for="thirteen">Reproducción de audio</label> <input id="thirteen" type="checkbox"><div class="index_list"> Este evento solo puede ser activado por las <a href=
"../../../3_scripting/4_gml_reference/audio/audio%20buffers.html">funciones de reproducción de la cola de audio</a> y devolverá un <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> almacenado en la variable <tt>async_load</tt>, que contiene diferentes pares clave / valor relacionados con la cola de audio que ha activado el evento. El evento se activa cuando ha seleccionado una cola de audio para reproducir y un búfer en esa cola de audio ha terminado de reproducirse. <br><br> Las siguientes claves estarán disponibles en ds_map: <br><br><ul><li> &quot; <b>queue_id</b> &quot;: el índice de cola para la cola que ha terminado de reproducirse, como lo devuelve la función <a href=
"../../../3_scripting/4_gml_reference/audio/audio_create_play_queue.html"><tt>audio_create_play_queue</tt></a>. </li><li> &quot; <b>buffer_id</b> &quot; - el ID de búfer para el búfer que ya no se reproduce desde </li><li> &quot; <b>queue_shutdown</b> &quot;: se establece en 0 durante la reproducción normal y 1 cuando se recibe el evento porque <a href=
"../../../3_scripting/4_gml_reference/audio/audio_free_play_queue.html"><tt>audio_free_play_queue</tt></a> ha sido llamado. Cuando se configura en 1, no desea poner en cola ningún otro dato. </li></ul> Dado que se puede crear una cola de audio a partir de múltiples búferes, este evento se puede desencadenar varias veces para una cola a medida que se llega al final de cada sección de audio con búfer, de ahí la clave &quot;buffer_id&quot;. <br><br><div class="note"> <b>NOTA:</b> La variable <tt>async_load</tt> Sólo es válido en los eventos asíncronos, ya que el <tt>ds_map</tt> es decir, se crea un punto al inicio del evento, y luego se elimina de nuevo al final, con esta variable restablecida a un valor de -1. Sin embargo, todas las estructuras de datos adicionales creadas a partir del evento <b>deben limpiarse utilizando las funciones apropiadas</b>. </div><br> En el ejemplo de uso que se da a continuación, crearemos una cola de audio con 10 sonidos de audio con búfer agregados y luego reproduciremos la cola: <br><br><p class="code">audio_queue = audio_create_play_queue(buffer_s16,
11052, audio_mono);<br>
for (var i = 0; i &lt; 10; i++;)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;audio_queue_sound(audio_queue, audio_buffer[i],
0, buffer_get_size(audio_buffer[i]));<br>
&nbsp;&nbsp;&nbsp;}<br>
audio_play_sound(audio_queue, 0, true);<br><span class="notranslate"></span></p><br> Cada paso del juego ahora que se detecta la grabación desencadenará un evento de grabación de audio asíncrono en el que puede tratar con la entrada grabada algo como esto: <br><br><p class="code">var queue = async_load[? "queue_id"];<br>
var num = 0;<br>
if queue = audio_queue<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;for (var i = 0; i &lt; 10; i++;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if async_load[? "buffer_id"] ==
audio_buffer[i]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer_seek(audio_buffer[i],
buffer_seek_start, 0);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num = i;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;if num == 9<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;audio_stop_sound(audio_queue);<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;audio_free_play_queue(audio_queue);<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> Aquí verificamos el ID de la cola y, si es el que queremos, verificamos el ID del búfer para ver qué búfer ha terminado de reproducirse. Luego, también establecemos una var local para ese valor de índice para su comprobación posterior y establecemos el búfer de nuevo para el inicio de ese sonido. Una vez que nuestra variable local llega a 9, lo que indica que la cola ha finalizado, dejamos de reproducir el sonido y liberamos la cola. </div><br><a name="async_audio_rec" id="async_audio_rec"></a> <label class=
"collapse" for="twelve">Grabación de audio</label> <input id="twelve"
type="checkbox"><div class="index_list"> Este evento solo puede ser activado por el <a href=
"../../../3_scripting/4_gml_reference/audio/audio_start_recording.html"><tt>audio_start_recording()</tt></a> función y devolverá un <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> almacenado en la variable <tt>async_load</tt>, que contiene diferentes pares clave / valor dependiendo de la devolución de llamada de la función que ha activado el evento. <br><br> Las siguientes claves estarán disponibles en ds_map: <br><br><ul><li> &quot; <b>buffer_id</b> &quot;: el ID del búfer temporal que puede usar para recuperar los datos de audio </li><li> &quot; <b>channel_index</b> &quot;: el índice del canal de grabación devuelto por la función de llamada de la que provienen estos datos </li><li> &quot; <b>data_len</b> &quot;: la longitud de los datos (en bytes) que ha recibido </li></ul><div class="note"> <b>NOTA:</b> Como se mencionó al inicio de esta página, la variable <tt>async_load</tt> Sólo es válido en los eventos asíncronos, ya que el <tt>ds_map</tt> es decir, se crea un punto al comienzo del evento y luego se elimina de nuevo al final. Sin embargo, tenga en cuenta que el búfer temporal en el que se almacena todo el audio con el mapa también se eliminará al final del evento, por lo que debe copiarlo en un búfer personalizado si desea conservarlo para su uso posterior. </div><br> En el siguiente ejemplo de uso, crearemos un búfer personalizado para almacenar nuestro audio grabado y también configuraremos nuestro juego para grabar desde la fuente de entrada 0: <br><br><p class="code">channel_index = audio_start_recording(0);<br>
audio_buffer = buffer_create(len, buffer_fast, 1);<br><span class="notranslate"></span></p><br> Cada paso del juego ahora que se detecta la grabación desencadenará un evento de grabación de audio asíncrono en el que puede tratar con la entrada grabada algo como esto: <br><br><p class="code">var channel = async_load[? "channel_index"];<br>
if channel == channel_index<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;len = async_load[? "data_len"];<br>
&nbsp;&nbsp;&nbsp;buffer_copy(async_load[? "buffer_id"], 0, len,
audio_buffer, 0);<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> Aquí simplemente verificamos la clave &quot;channel_index&quot; para asegurarnos de que coincida con el valor devuelto cuando comenzamos a grabar, y si lo hace, copiamos el contenido del búfer temporal creado para este evento en nuestro búfer personalizado. Después de eso, puede hacer lo que quiera con el búfer personalizado: puede reproducirlo utilizando las funciones de audio del búfer dedicado, puede procesarlo y enviarlo a través de la red, puede guardarlo en el disco... Una vez que tenga su audio grabado En un búfer, puedes hacer básicamente lo que quieras. </div><br><a name="async_cloud" id="async_cloud"></a> <label class="collapse"
for="five">Nube</label> <input id="five" type="checkbox"><div class="index_list"> El Evento en la Nube es uno que se activa por la devolución de llamada de uno de los <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/index.html"><tt>cloud_</tt> funciones</a>, como <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/cloud_synchronise.html"><tt>cloud_synchronise</tt></a>. En realidad genera un <tt>ds_map</tt> esto es exclusivo de este evento y se almacena en la variable especial <b>async_load</b> (consulte las funciones individuales para ver ejemplos de código que explican el uso de este evento con más detalle). Este ds_map tiene la siguiente estructura: <br><br><ul><li> <b>&quot;estado&quot;:</b> contiene el código de estado, donde un valor negativo denota un error, cuya descripción se incluirá en el &quot;errorString&quot;. Un valor de 0 (o un valor positivo) indica un éxito (consulte a continuación los valores exactos), y la &quot;cadena de resultados&quot; contendrá los datos devueltos o un mensaje de éxito. </li><li style="list-style: none"><br></li><li> <b>&quot;id&quot;:</b> el id que se devolvió de la función llamada. Si disparas una serie de <tt>cloud_</tt> las solicitudes, entonces necesita saber a cuál le está respondiendo, por lo que usaría este valor para comparar con el valor que almacenó cuando envió originalmente la solicitud para encontrar la correcta. </li><li style="list-style: none"><br></li><li> <b>&quot;description&quot;:</b> la descripción del último archivo cargado. </li><li style="list-style: none"><br></li><li> <b>&quot;resultString&quot;:</b> contiene una cadena que es el blob de datos devuelto desde la nube. </li><li style="list-style: none"><br></li><li> <b>&quot;errorString&quot;:</b> devuelve una cadena de error para cualquier error. </li></ul> El significado exacto de la entrada del mapa &quot;estado&quot; devuelto se explica en la siguiente tabla: <div class="compat"><table><tr><th> Valor de estado </th><th> errorString / resultString </th><th> Descripción </th></tr><tr><td> <span class="notranslate">-1</span> </td> <td> errorString = &quot;No se ha iniciado sesión en &lt;SERVICE&gt;&quot; </td><td> <span class="notranslate">You have not successfully logged in to the given Cloud Service</span> </td> </tr><tr class="alt"><td> <span class="notranslate">0</span> </td> <td> resultString = datos recuperados </td><td> <span class="notranslate">New game data downloaded from the cloud (following a cloud_synchronise call)</span> </td> </tr><tr><td> <span class="notranslate">1</span> </td> <td> resultString = &quot;AlreadySynchronized&quot; </td><td> <span class="notranslate">No new data since you last called cloud_synchronise</span> </td> </tr><tr class="alt"><td> <span class="notranslate">2</span> </td> <td> resultString = &quot;ConflictDeferral&quot; </td><td> <span class="notranslate">A conflict was encountered, but the gamer chose to ignore it</span> </td> </tr><tr><td> <span class="notranslate">3</span> </td> <td> resultString = &quot;GameUploadSuccess&quot; </td><td> <span class="notranslate">data from <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/cloud_string_save.html"><tt>cloud_string_save</tt></a> or <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/cloud_file_save.html"><tt>cloud_file_save</tt></a> was successfully uploaded to the cloud</span> </td> </tr><tr class="alt"><td> <span class="notranslate">-n</span> </td> <td> errorString = Descripción del error </td><td> <span class="notranslate">Any other negative number means a synchronisation failure</span> </td> </tr></table></div></div><br><a name="async_dialogue" id="async_dialogue"></a> <label class=
"collapse" for="three">Diálogo</label> <input id="three" type=
"checkbox"><div class="index_list"> Al igual que los eventos anteriores, el evento <b>Diálogos</b> solo se desencadena cuando recibe una llamada de una de las funciones asíncronas especiales del usuario, como <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/get_login_async.html"><tt>get_login_async()</tt></a> (Consulte esta función para ver un ejemplo de código extendido de cómo se usa este evento). Estos eventos son los que solicitan algún tipo de información del usuario, que puede ser un nombre, detalles de inicio de sesión, un número o un color, etc. Como la mayoría de los dispositivos no les gusta sentarse en un bucle esperando una respuesta, tienen que: ser asíncrono y <i><span class="notranslate">GameMaker Studio 2</span></i> continuará ejecutándose en segundo plano mientras estas funciones tengan un diálogo abierto y hasta que obtengan la entrada del usuario requerida que activa este evento. <br><br> De nuevo, un <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> se devuelve con el ID en la variable especial <b>async_load</b>. Los valores que se conservan en este mapa dependerán de la función utilizada, y debe consultar las entradas individuales de cada función en este manual para obtener más detalles. </div><br><a name="async_http" id="async_http"></a> <label class="collapse"
for="two">HTTP</label> <input id="two" type="checkbox"><div class="index_list"> El evento HTTP es uno que se activa por la devolución de llamada de uno de los <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/index.html"><tt>http_</tt> funciones</a>, como <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/http_post_string.html"><tt>http_post_string</tt></a>. En realidad genera un <tt>ds_map</tt> (a veces conocido como &quot;diccionario&quot;) que es exclusivo de este evento y se almacena en la variable especial <tt>async_load</tt> (Consulte las funciones individuales para obtener ejemplos de código que explican el uso de este evento con más detalle). Esta <tt>ds_map</tt> Tiene la siguiente estructura: <br><br><ul><li> <b>&quot;id&quot;:</b> el id que fue devuelto desde el comando. Si disparas una serie de <tt>http_</tt> las solicitudes, entonces necesita saber a cuál le está respondiendo, por lo que usaría este valor para comparar con el valor que almacenó cuando envió originalmente la solicitud para encontrar la correcta. </li><li style="list-style: none"><br></li><li> <b>&quot;estado&quot;:</b> devuelve un valor inferior a 0 para un error, 0 para éxito y 1 si el contenido se está descargando. </li><li style="list-style: none"><br></li><li> <b>&quot;resultado&quot;:</b> los datos recibidos (solo cadena), o la ruta al archivo descargado si ha usado <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/http_get_file.html"><tt>http_get_file()</tt></a>. </li><li style="list-style: none"><br></li><li> <b>&quot;url&quot;:</b> la URL completa que solicitó. </li><li style="list-style: none"><br></li><li> <b>&quot;http_status&quot;:</b> el código de estado http sin procesar (si está disponible). Esto devuelve el código de estado web estándar para la mayoría de los navegadores, por ejemplo: 304 para &quot;No modificado&quot; o 204 para &quot;Sin contenido&quot;, etc. </li></ul> Eso es para cuando usas el <tt>http_post_string()</tt> función, pero cada uno de los <tt>http_</tt> las funciones pueden devolver un mapa ligeramente diferente, por lo tanto, consulte la entrada manual de cada función para conocer los datos precisos que se le devuelven. <br><br><div class="note"> <b>NOTA:</b> Como <tt>async_load</tt> crea un <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a>, estas funciones son particularmente útiles cuando se combinan con el <a href=
"../../../3_scripting/4_gml_reference/file%20handling/json_encode.html"><tt>json_encode</tt></a> y <a href=
"../../../3_scripting/4_gml_reference/file%20handling/json_decode.html"><tt>json_decode</tt></a> funciones </div><br><br> También puede haber datos adicionales proporcionados por este mapa si ha solicitado archivos para descargar. En este caso, el &quot;estado&quot; tendrá un valor de 1 y el ds_map contendrá estas claves adicionales: <br><br><ul><li> <b>&quot;contentLength&quot;:</b> es el tamaño del archivo que el servidor web ha dicho que debe esperar recibir (puede ser -1 si el servidor no devuelve estos datos). </li><li style="list-style: none"><br></li><li> <b>&quot;sizeDownloaded&quot;:</b> el tamaño de los datos que ya se han descargado. </li></ul> Tenga en cuenta que el evento <i>no</i> se activará para cada paquete de datos que se reciba, sino que se actualizará en cualquier momento durante la descarga dentro del bucle principal del juego. También tenga en cuenta que actualmente esta funcionalidad solo está disponible para las plataformas de destino normales de <i>Windows</i>. </div><br><a name="async_iap" id="async_iap"></a> <label class="collapse"
for="four">IAP</label> <input id="four" type="checkbox"><div class="index_list"> Este evento solo puede activarse cuando hayas activado las <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/index.html">compras en la aplicación</a> para tu juego. Si tiene esta funcionalidad agregada, entonces el evento se activará en las siguientes circunstancias: <br><br><ul><li> El estado de la tienda cambia. </li><li> Un producto (o productos) ha sido activado. </li><li> El producto y las compras han sido restaurados. </li><li> Un producto ha sido comprado. </li><li> Se ha consumido un producto. </li></ul> El evento siempre creará un especial. <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> con una identificación de índice almacenada en la variable incorporada <tt><b>iap_data</b></tt>. Este mapa <i>siempre</i> contendrá la clave &quot; <b>tipo</b> &quot;, que contendrá uno de los siguientes valores constantes: <div class="compat"><table><tr><th> Constante </th><th> Descripción </th></tr><tr><td> <span class="notranslate">iap_ev_storeload</span> </td> <td> Esto se activa cuando se detecta un cambio en el almacén de la plataforma de destino. </td></tr><tr class="alt"><td> <span class="notranslate">iap_ev_product</span> </td> <td> Este evento se activa cuando se activa un producto y contendrá información adicional sobre el producto. </td></tr><tr><td> <span class="notranslate">iap_ev_restore</span> </td> <td> Este evento solo se activa cuando se usa el <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_restore_all.html"><tt>iap_restore_all</tt></a> función. </td></tr><tr class="alt"><td> <span class="notranslate">iap_ev_purchase</span> </td> <td> Cuando una compra se ha completado, este evento se activa. </td></tr><tr><td> <span class="notranslate">iap_ev_consume</span> </td> <td> Cuando usas la función <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_consume.html"><tt>iap_consume</tt></a> se dispara este evento. </td></tr></table></div><p><br><br> Cada uno de estos posibles &quot;tipos&quot; de evento agregará claves adicionales a la <tt>iap_data</tt> ds_map, que luego puede analizarse para obtener la información de compra o producto necesaria. El contenido exacto de la <tt>iap_data</tt> mapa se enumeran a continuación para cada evento &quot;tipo&quot;. </p><blockquote><a name="iap_ev_storeload" id="iap_ev_storeload"></a> <label class="collapse" for="fifteen">iap_ev_storeload</label> <input id="fifteen" type="checkbox"><div class="index_list"> Cuando active sus compras, su juego intentará ponerse en contacto con la tienda objetivo, lo que provocará este evento en el proceso. los <tt>iap_data</tt> entonces el mapa tendrá una clave de adición &quot; <b>estado&quot;</b>, que tendrá una de las siguientes constantes como valor: <br><br><div class="compat"><table><tr><th> Constante </th><th> Descripción </th></tr><tr><td> <span class="notranslate">iap_storeload_ok</span> </td> <td> La tienda ha sido contactada y la conexión es buena. </td></tr><tr class="alt"><td> <span class="notranslate">iap_storeload_failed</span> </td> <td> Se ha producido un error de conexión o, por algún motivo, la tienda no está disponible. </td></tr></table></div></div><br><a name="iap_ev_product" id="iap_ev_product"></a> <label class=
"collapse" for="sixteen">iap_ev_product</label> <input id="sixteen"
type="checkbox"><div class="index_list"> Todas las compras activadas activarán este &quot;tipo&quot; de evento, pero solo una vez por compra, así que si ha activado diez productos, debe esperar que este evento se active diez veces. Si ha recibido este evento, el <tt>iap_data</tt> ds_map mantendrá la clave &quot; <b>índice</b> &quot; adicional que contiene la <b>cadena de ID de producto</b> única para el producto que se está activando. A continuación, puede utilizar la función <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_product_details.html"><tt>iap_product_details</tt></a> junto con esta identificación del producto para obtener más información. <br><br><div class="note"> <b>NOTA:</b> Google Play ( <span class="notranslate">Android</span> ) solo puede solicitar detalles de los productos 20 a la vez, lo que puede llevar a tiempos de carga bastante largos para aplicaciones con un número significativo de productos. </div></div><br><a name="iap_ev_restore" id="iap_ev_restore"></a> <label class=
"collapse" for="seventeen">iap_ev_restore</label> <input id=
"seventeen" type="checkbox"><div class="index_list"> Cuando llamas a la función <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_restore_all.html"><tt>iap_restore_all</tt></a> activará este evento, agregando una clave de &quot; <b>resultado</b> &quot; a la <tt>iap_data</tt> ds_map. Esta tecla mantendrá bien <tt>true</tt> o <tt>false</tt> para indicar si los datos de compra se han restaurado correctamente desde la tienda de destino. </div><br><a name="iap_ev_purchase" id="iap_ev_purchase"></a> <label class=
"collapse" for="eighteen">iap_ev_purchase</label> <input id=
"eighteen" type="checkbox"><div class="index_list"> Al solicitar una compra utilizando la función. <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_acquire.html"><tt>iap_acquire</tt></a> este tipo de evento se activará. los <tt>iap_data</tt> ds_map tendrá la clave &quot; <b>índice</b> &quot; adicional que contiene el valor de <b>ID de compra</b> único para el producto que se está comprando. A continuación, puede utilizar la función <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_purchase_details.html"><tt>iap_purchase_details</tt></a> junto con este ID de compra para obtener más información. <br><br><div class="note"> <b>NOTA:</b> Si el producto comprado es consumible, entonces <b>debe usarse</b> usando <tt>iap_consume</tt> antes de una nueva compra se puede hacer. </div></div><br><a name="iap_ev_consume" id="iap_ev_consume"></a> <label class=
"collapse" for="nineteen">iap_ev_consume</label> <input id=
"nineteen" type="checkbox"><div class="index_list"> Al usar la función <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_consume.html"><tt>iap_consume</tt></a> este tipo de evento se activará. los <tt>iap_data</tt> ds_map tendrá la clave adicional &quot; <b>producto</b> &quot; que contiene la cadena de <b>ID de producto</b> única para el producto que se consume. </div></blockquote></div><br><a name="async_image_loaded" id="async_image_loaded"></a> <label class="collapse" for="one">Imagen cargada</label> <input id=
"one" type="checkbox"><div class="index_list"> Este evento se activa cuando carga una imagen en <i><span class="notranslate">GameMaker Studio 2</span></i>, siempre y cuando haya utilizado una URL o ruta válida con la función de carga del archivo correspondiente. Por ejemplo, digamos que desea cargar una imagen de sprite, y solo cambie el sprite actual para la instancia a la nueva cuando se haya cargado. Bueno, tendrías algo como esto en un evento crear o un evento de alarma (por ejemplo): <p class="code">spr =
sprite_add("http://www.angusgames.com/game/background1.png", 0,
false, false, 0, 0);<span class="notranslate"></span></p><p> Ahora comenzará a cargar la imagen en el dispositivo o en el navegador, pero <i>no</i> bloqueará <i><span class="notranslate">GameMaker Studio 2</span></i> mientras espera a que se cargue el archivo. En cambio, <i><span class="notranslate">GameMaker</span> Studio 2</i> seguirá funcionando normalmente hasta que la imagen se cargue y la devolución de llamada active el evento <b>Image Loaded</b>, donde <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> Se crea y almacena en la variable especial <b>async_load</b>. El mapa contiene la siguiente información: </p><ul><li> <b>&quot;nombre de archivo&quot;:</b> la ruta completa al archivo que solicitó. </li><li style="list-style: none"><br></li><li> <b>&quot;id&quot;:</b> el ID del recurso que ha cargado. Esta será la misma que la variable a la que ha asignado el recurso. </li><li style="list-style: none"><br></li><li> <b>&quot;estado&quot;:</b> devuelve un valor inferior a 0 para un error. </li></ul><p> A continuación, asignará la imagen recién cargada a un fondo en este evento. Lo anterior también es válido para sprites y sonidos, con un ds_map generado para cada uno de estos recursos como se muestra arriba, y el siguiente ejemplo de código demuestra cómo se usaría la información devuelta en este evento: </p><p class="code">if ds_map_find_value(async_load, "id") == spr<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;if ds_map_find_value(async_load, "status") &gt;=
0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprite_index = spr<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><p> El código anterior primero verificará la identificación del ds_map que se ha creado, luego verificará el estado de la devolución de llamada. Si el valor es mayor o igual a 0 (señalización exitosa), el resultado de la devolución de llamada se utilizará para establecer el índice de fondo a la imagen recién cargada. </p></div><br><a name="async_networking" id="async_networking"></a> <label class=
"collapse" for="six">Redes</label> <input id="six" type=
"checkbox"><div class="index_list"> El evento de red es uno que se activará por cualquier tráfico de red entrante y está vinculado a las <a href=
"../../../3_scripting/4_gml_reference/networking/index.html">funciones de red</a>. Este evento genera un <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html">ds_map</a> especial que es exclusivo de este evento y se almacena en la variable especial <b>async_load</b>. Esta <tt>ds_map</tt> Contendrá información diferente dependiendo del tipo de evento de red que lo generó. <blockquote><a name="async_network_common" id=
"async_network_common"></a> <label class="collapse" for=
"twenty">Eventos comunes de redes</label> <input id="twenty" type=
"checkbox"><div class="index_list"> Las siguientes teclas son comunes a todas las funciones de red recibidas y siempre estarán presentes en el <tt>async_load</tt> mapa: <br><br><ul><li> <b>&quot;tipo&quot;:</b> tendrá una de las constantes enumeradas a continuación como valor de retorno y designa el tipo de evento de red. </li><li style="list-style: none"><br></li><li> <b>&quot;id&quot;:</b> el id del socket (un número real, como lo devuelve la función <a href=
"../../../3_scripting/4_gml_reference/networking/network_create_server.html">network_create_server</a> o <a href=
"../../../3_scripting/4_gml_reference/networking/network_create_socket.html">network_create_socket</a> ) que está recibiendo el evento. En la mayoría de los casos, el ID de socket devuelto es el ID de TCP o UDP socket que activó el evento; sin embargo, si el evento se activa en un <i>servidor</i> y es un evento de datos (ver más abajo), el ID de socket es el del <i>cliente</i> que envió el datos. </li><li style="list-style: none"><br></li><li> <b>&quot;ip&quot;:</b> la dirección IP del socket (como una cadena). </li><li style="list-style: none"><br></li><li> <b>&quot;puerto&quot;:</b> el puerto asociado con la dirección IP (útil cuando se trabaja con UDP). </li></ul> Los valores de retorno posibles para la tecla &quot;tipo&quot; pueden ser cualquiera de las tres constantes enumeradas a continuación: <div class="compat"><table><tr><th> Constante </th><th> Descripción </th></tr><tr><td> <span class="notranslate">network_type_connect</span> </td> <td> El evento fue desencadenado por una conexión. </td></tr><tr class="alt"><td> <span class="notranslate">network_type_disconnect</span> </td> <td> El evento fue desencadenado por una desconexión. </td></tr><tr><td> <span class="notranslate">network_type_data</span> </td> <td> El evento fue activado por los datos entrantes. </td></tr><tr class="alt"><td> <span class="notranslate">network_type_non_blocking_connect</span> </td> <td> El evento fue activado por una conexión configurada como no bloqueante (puede usar la función <a href=
"../../../3_scripting/4_gml_reference/networking/network_set_config.html"><tt>network_set_config()</tt></a> para esto). </td></tr></table></div></div><br><a name="async_network_connect" id="async_network_connect"></a> <label class="collapse" for="twentyone">Conectar / Desconectar</label> <input id="twentyone" type="checkbox"><div class="index_list"> Cuando tengas un evento del tipo <tt>network_type_connect</tt>, <tt>network_type_non_blocking_connect</tt> o <tt>network_type_disconnect</tt>, la <tt>async_load</tt> El mapa tendrá las siguientes teclas adicionales: <br><br><ul><li> <b>&quot;socket&quot;:</b> esta tecla mantendrá la conexión / desconexión del ID de socket. </li><li style="list-style: none"><br></li><li> <b>&quot;exitoso&quot;:</b> esta clave será 0 o 1, donde 0 significa que la conexión se agotó y 1 significa que tuvo éxito y que el socket está listo para usar. </li></ul> Vale la pena señalar que el Evento de red no se activa en los <i>clientes</i> cuando el <i>servidor se</i> desconecta, y que ninguno de los <tt>network_type_*</tt> los eventos se activarán en los clientes cuando el servidor al que están conectados se desconecte, incluso si la conexión se basa en TCP. </div><br><a name="async_network_receive" id="async_network_receive"></a> <label class="collapse" for="twentytwo">Recibiendo información</label> <input id="twentytwo" type="checkbox"><div class="index_list"> Cuando usted tiene una <tt>network_type_data</tt> escriba evento, que significa que su red ha recibido datos, el mapa creado tendrá las siguientes claves: <br><br><ul><li> <b>&quot;búfer&quot;:</b> este es el único &quot;id de búfer&quot; generado por el evento. Se crea un búfer de tipo &quot;crecer&quot;, byte alineado a 1, para contener el id. Debe almacenarse en una variable y usarse para todas las demás llamadas de función al búfer <i><b>en este evento</b></i>. Al igual que el <tt>async_load</tt> mapa, el búfer creado se elimina automáticamente de la memoria al final de este evento. Para obtener más información sobre los buffers, consulte <a href=
"../../../3_scripting/4_gml_reference/buffers/index.html">Referencia - Buffers.</a> </li><li style="list-style: none"><br></li><li> <b>&quot;tamaño&quot;:</b> este es el tamaño (en bytes) de los datos del búfer que se están recibiendo. </li></ul><div class="note"> <b>NOTA:</b> El búfer creado <b>solo</b> es <b>válido en estos eventos</b> y se liberará cuando finalice el evento. </div></div></blockquote></div><br><a name="async_push" id="async_push"></a> <label class="collapse"
for="ten">Notificación de inserción</label> <input id="ten" type=
"checkbox"><div class="index_list"> El evento de notificación de inserción es uno que es activado por la devolución de llamadas desde <b>notificaciones de inserción</b> en el sistema operativo del dispositivo, ya sea desde una fuente local que usa la función <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/push_local_notification.html"><tt>push_local_notification</tt></a>, o desde una fuente remota (es decir, su servidor). Genera un <tt>ds_map</tt> esto es exclusivo de este evento y se almacena en la variable especial <b>async_load</b> (consulte las funciones individuales que activan eventos asíncronos para obtener ejemplos de código que explican el uso de este evento con más detalle). Esta <tt>ds_map</tt> tiene las siguientes teclas: <br><br><ul><li> <b>&quot;tipo&quot;: el</b> valor puede ser &quot;local&quot; para una notificación local del dispositivo, &quot;remoto&quot; para una notificación remota o &quot;registro&quot; para el registro de notificaciones remotas. </li><li> <b>&quot;estado&quot;: el</b> valor será &quot;1&quot; para el éxito o &quot;0&quot; para un error. </li></ul> Puede haber entradas de clave adicionales basadas en el &quot;tipo&quot; devuelto y el valor de &quot;estado&quot;. Para &quot;estado&quot;, si se ha devuelto un error (&quot;0&quot;), también tendrá la siguiente clave: <br><br><ul><li> <b>&quot;error&quot;:</b> contiene detalles del error recibido. </li></ul> Si el valor de &quot;estado&quot; es 1 (es decir, sin errores), entonces el <tt>ds_map</tt> contendrá los siguientes valores adicionales, dependiendo del valor de la clave &quot;tipo&quot;: <br><br><ul><li> <b>&quot;reg_id&quot;:</b> si el &quot;tipo&quot; recibido fue &quot;registro&quot;, esta tecla mantendrá la identificación de registro del dispositivo para notificaciones remotas. </li><li> <b>&quot;datos&quot;:</b> si el &quot;tipo&quot; recibido fue &quot;local&quot; o &quot;remoto&quot;, esta clave mantendrá la carga útil de la cadena que definió cuando llamó a la función de notificación. </li></ul> Para entenderlo mejor, hemos creado un pequeño fragmento de ejemplo a continuación para que lo veas. En este ejemplo, enviaremos una notificación de inserción local utilizando el siguiente código: <br><br><p class="code">var fireTime =
date_inc_day(date_current_datetime(), 1);<br>
var data = "daily_reward";<br>
push_local_notification(fireTime, "Ahoy!", "Catch The Haggis Has A
Present", data);<br><span class="notranslate"></span></p><br> Esto establecerá un temporizador para &quot;enviar&quot; una notificación al dispositivo cuando haya pasado un día. Cuando termine el día, si su juego está en segundo plano o no se está ejecutando, se mostrará una notificación al usuario con el título y el mensaje dados (en iOS, se muestra el nombre del juego y se ignora el título), y luego Se llamará un evento de notificación push asíncrono. Tenga en cuenta que si el juego está en primer plano cuando llega la hora de la notificación, <i>no</i> se mostrará, pero el evento asíncrono <b>todavía se activará</b>. En el caso de que usted maneje la devolución de llamada algo como esto: <br><br><p class="code">var type = ds_map_find_value(async_load,
"type");<br>
var status = ds_map_find_value(async_load, "status");<br>
if status == 0<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;//error of some kind<br>
&nbsp;&nbsp;&nbsp;var error = ds_map_find_value(async_load,
"error");<br>
&nbsp;&nbsp;&nbsp;show_debug_message("error=" + string(error));<br>
&nbsp;&nbsp;&nbsp;}<br>
else<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;if type == "register"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;global.reg_id =
ds_map_find_value(async_load, "reg_id");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var data =
ds_map_find_value(async_load, "data");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if data ==
"daily_reward"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;global.Gold
+= 1000;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p></div><br><a name="async_saveload" id="async_saveload"></a> <label class=
"collapse" for="eleven">Guardar carga</label> <input id="eleven"
type="checkbox"><div class="index_list"> Este evento se activará mediante ciertas funciones relacionadas con la carga y el almacenamiento de búferes en archivos, así como al cargar o descargar audio de la memoria. El evento en sí contendrá el construido en <tt>async_load</tt> Mapa DS que se rellenará con las teclas necesarias para la función específica. Estos se enumeran en las secciones a continuación. <blockquote><a name="async_saveload_buffers" id=
"async_saveload_buffers"></a> <label class="collapse" for=
"twentynine">Tampones</label> <input id="twentynine" type=
"checkbox"><div class="index_list"> Cuando usas las funciones <a href=
"../../../3_scripting/4_gml_reference/buffers/buffer_save_async.html"><tt>buffer_save_async()</tt></a> o <a href=
"../../../3_scripting/4_gml_reference/buffers/buffer_load_async.html"><tt>buffer_load_async()</tt></a> un evento asíncrono se activará cuando se haya completado la transferencia de datos. Este evento poblará el <tt>async_load</tt> mapa con los siguientes pares clave / valor <br><br><ul><li> <b>&quot;id&quot;:</b> el ID de la función asíncrona tal como lo devuelve la función utilizada. </li><li> <b>&quot;estado&quot;:</b> volverá <tt>true</tt> si los datos fueron guardados / cargados correctamente, y <tt>false</tt> de otra manera. </li></ul> Esto le permite encuestar el progreso de guardado / guardado y mostrar un mensaje o cambiar de sala, etc. cuando se complete el proceso. </div><br><a name="async_saveload_audio" id="async_saveload_audio"></a> <label class="collapse" for="thirty">Grupos de audio</label> <input id="thirty" type="checkbox"><div class="index_list"> Cuando trabaje con <a href=
"../../../3_scripting/4_gml_reference/audio/audio%20groups.html">grupos de audio</a>, puede cargarlos y descargarlos de la memoria usando las funciones <a href=
"../../../3_scripting/4_gml_reference/audio/audio_group_load.html"><tt>
audio_group_load()</tt></a> y <a href=
"../../../3_scripting/4_gml_reference/audio/audio_group_unload.html"><tt>audio_group_unload()</tt></a>. Al usar la función de carga, activará este evento cuando el conjunto completo de archivos de audio establecidos para el grupo se haya cargado en la memoria y llenará el mapa con los siguientes pares clave / valor: <br><br><ul><li> <b>&quot;tipo&quot;:</b> esto nos dice el tipo de evento al que se llama y será &quot; <tt>audiogroup_load</tt> &quot;para cargar audio. </li><li> <b>&quot;group_id&quot;:</b> devolverá el ID del grupo de audio que se ha cargado (como se define en el <a href=
"c:/source/yoyostudio/documentation/english/2_interface/3_settings/audio.html">Editor de grupo de audio</a> ). </li></ul> Cuando todo el audio se ha cargado para un grupo, este evento se activará y luego se podrá usar para cambiar de habitación, reproducir una pista de música, etc. </div></blockquote></div><br><a name="async_social" id="async_social"></a> <label class=
"collapse" for="eight">Social</label> <input id="eight" type=
"checkbox"><div class="index_list"> Este evento solo puede ser activado por las diversas <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/index.html">funciones sociales</a> específicas y devolverá un <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> almacenado en la variable <tt>async_load</tt>, que contiene diferentes pares clave / valor en función de la devolución de llamada de la función que ha activado el evento. <br><br> El ds_map contendrá una serie de claves, la más importante de las cuales es la clave &quot; <i>id</i> &quot;. Esto devolverá una <b>constante</b> que luego puede verificarse en el código para determinar cuál de las muchas devoluciones de llamada ha recibido el evento. Una vez que haya analizado esta clave y comparado el valor devuelto con las constantes disponibles, puede continuar extrayendo el resto de la información del mapa. <blockquote><a name="async_social_leaderboards" id=
"async_social_leaderboards"></a> <label class="collapse" for=
"twentyseven">Tablas de clasificación y logros</label> <input id=
"twentyseven" type="checkbox"><div class="index_list"> Las páginas de funciones en <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/achievements%20and%20leaderboards/index.html">Juego social - Logros y tablas</a> de <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/achievements%20and%20leaderboards/index.html">clasificación</a> en la sección Referencia detallan las funciones y las devoluciones de llamada, así como las constantes utilizadas para desencadenar este evento, pero también hay ciertas circunstancias en las que se activará sin una llamada de función del juego que Esta corriendo: <br><br><ul><li> cuando su juego se inicia desde el panel de control del sistema operativo </li><li> cuando completes un reto </li><li> cuando otro jugador completa un desafío </li><li> cuando el juego se inicia desde el panel del sistema operativo seleccionando un desafío </li></ul><p> Cualquiera de las devoluciones de llamada anteriores activará el <b>Evento social</b> y un <tt>async_load</tt> el mapa se generará con los siguientes detalles (tenga en cuenta que hay un valor de clave &quot;id&quot; diferente para definir cada una de las diferentes razones por las que se llamó al evento, pero todos los demás contenidos del mapa son los mismos): <br><br></p><ul><li> &quot; <b>id</b> &quot;: el valor de esta clave dependerá del tipo de devolución de llamada que active el evento. Puede ser una de estas constantes: <br><br><ul><li> <b><tt>achievement_challenge_received</tt></b> - Se ha recibido un reto. <br></li><li> <b><tt>achievement_challenge_completed</tt></b> - Se ha completado un desafío. <br></li><li> <b><tt>achievement_challenge_completed_by_remote</tt></b> - Un desafío ha sido completado por el otro jugador. <br></li><li> <b><tt>achievement_challenge_launched</tt></b> - El juego se lanzó desde el panel del sistema operativo con el desafío dado. <br></li></ul></li><li> &quot; <b>playerid</b> &quot; - La identificación del jugador para el desafío. <br><br></li><li> &quot; <b>issuerid</b> &quot;: el id de la persona que emitió el desafío. <br><br></li><li> &quot; <b>estado</b> &quot;: el estado del desafío, que tendrá un valor de 0 - 3 (como una cadena) para <i>inválido</i>, <i>pendiente</i>, <i>completado</i> o <i>rechazado</i>. <br><br></li><li> &quot; <b>mensaje</b> &quot; - El mensaje de texto para desafío. <br><br></li><li> &quot; <b>issuedate</b> &quot; - La fecha de emisión para impugnación <br><br></li><li> &quot; <b>completeddate</b> &quot;: la fecha de finalización del desafío. <br><br></li><li> &quot; <b>tipo</b> &quot; - El tipo de desafío dado. Puede ser una de las dos constantes: <br><br><ul><li> <b><tt>achievement_type_score_challenge</tt></b> - Un desafío basado en el valor de puntuación. <br></li><li> <b><tt>achievement_type_achievement_challenge</tt></b> - Un reto basado en un logro. <br></li></ul></li><li> &quot; <b>identificador</b> &quot; - La cadena de identificación para el desafío. <br><br></li><li> &quot; <b>puntaje</b> &quot;: el puntaje vinculado al desafío. </li></ul> A continuación puede encontrar un pequeño fragmento de código como ejemplo de uso: <br><br><p class="code">var ident = ds_map_find_value(async_load, "id"
);<br>
if ident == achievement_challenge_completed;<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;player_id = ds_map_find_value(async_load,
"playerid");<br>
&nbsp;&nbsp;&nbsp;issuer_id = ds_map_find_value(async_load,
"issuerid");<br>
&nbsp;&nbsp;&nbsp;state = ds_map_find_value(async_load,
"state");<br>
&nbsp;&nbsp;&nbsp;date_completed = ds_map_find_value(async_load,
"completeddate");<br>
&nbsp;&nbsp;&nbsp;date_issued = ds_map_find_value(async_load,
"issueddate");<br>
&nbsp;&nbsp;&nbsp;ach_type = ds_map_find_value(async_load,
"type");<br>
&nbsp;&nbsp;&nbsp;ach_ident = ds_map_find_value(async_load,
"identifier");<br>
&nbsp;&nbsp;&nbsp;ach_score = ds_map_find_value(async_load,
"score");<br>
&nbsp;&nbsp;&nbsp;}<span class="notranslate"></span></p></div><br><a name="async_social_facebook" id="async_social_facebook"></a> <label class="collapse" for="twentyeight">Facebook</label> <input id="twentyeight" type="checkbox"><div class="index_list"> Algunas de las <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/facebook/index.html">funciones de Facebook</a> activarán un evento social asíncrono y crearán un <tt>ds_map</tt> Con alguna información específica. La información devuelta dependerá del &quot;tipo&quot; de evento que se haya llamado. Puede verificar esto leyendo la tecla &quot;tipo&quot; en ds_map, que será la siguiente cadena para un evento de Facebook: <br><br><ul><li> &quot; <b>facebook_permission_request</b> &quot; </li></ul><p> Cuando el evento se activa y es de este tipo, también habrá claves adicionales que se pueden verificar: </p><ul><li> &quot; <b>requestId</b> &quot;: el valor de ID de solicitud devuelto por el <tt>facebook_request_xxx_permission()</tt> Función que desencadenó el evento. <br><br></li><li> &quot; <b>resultado</b> &quot;: esta será una de las siguientes cadenas: <br><br><ul><li> &quot; <b>concedido</b> &quot;: los permisos fueron aceptados por el usuario </li><li> &quot; <b>denegado</b> &quot;: uno o más permisos no fueron aceptados por el usuario </li><li> &quot; <b>error</b> &quot; - ocurrió un error </li></ul></li><li> <b>&quot;error</b> &quot;: contendrá una descripción del error, pero <i>solo</i> estará presente cuando &quot; <b>result</b> &quot; = &quot; <b>error</b> &quot;. </li></ul></div></blockquote></div><br><a name="async_steam" id="async_steam"></a> <label class="collapse"
for="seven"><span class="notranslate">Steam</span></label> <input id="seven" type="checkbox"> <div class="index_list"> Este evento solo puede ser activado por las funciones de la <a href=
"../../../3_scripting/4_gml_reference/steam%20api/index.html">API de <span class="notranslate">Steam</span></a> y devolverá un <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> almacenado en la variable <tt>async_load</tt>, que contiene diferentes pares clave / valor dependiendo de la devolución de llamada de la función que ha activado el evento. El mapa siempre contendrá la clave &quot; <b>event_type</b> &quot;, que luego se puede analizar para encontrar el tipo de función que activó el evento y cambiar el código requerido para adaptarse. <br><br> Al llamar a cualquier función que active este evento, generará un valor de ID asíncrono único que debe almacenarse en una variable y verificarse, como <tt>async_load</tt> el mapa siempre contendrá una clave de identificación que luego podrá analizar y asegurarse de que está respondiendo al evento correcto. De hecho, el mapa <i>siempre</i> contendrá las siguientes teclas, independientemente de la función <span class="notranslate">Steam</span> utilizada para generar la respuesta asíncrona: <br><br><ul><li> &quot; <b>id</b> &quot;: el ID asíncrono devuelto por la función que activó el evento </li><li style="list-style: none"><br></li><li> &quot; <b>resultado</b> &quot;: el resultado de la operación (un valor real). Esta será la constante GML <tt>ugc_result_success</tt> o algún otro número real. Por lo tanto, debe verificar esta constante para asegurarse de que la llamada fue exitosa y, de lo contrario, algo no ha funcionado correctamente. El resto de los valores posibles devueltos se muestran como el resultado del valor &quot;EResult&quot; de <span class="notranslate">Steam</span> y debería ver <tt>steamclientpublic.h</tt> en los encabezados del SDK para los 89 valores posibles. </li><li style="list-style: none"><br></li><li> &quot; <b>event_type</b> &quot; - Una cadena que denota el tipo de evento (ver más abajo para más detalles) </li></ul><blockquote><a name="async_steam_uploading" id=
"async_steam_uploading"></a> <label class="collapse" for=
"twentythree">Cargando datos</label> <input id="twentythree" type=
"checkbox"><div class="index_list"> Cuando se usan las funciones de <span class="notranslate">Steam</span> para cargar una tabla de clasificación (ya sea <a href=
"../../../3_scripting/4_gml_reference/steam%20api/steam_upload_score.html"><tt>steam_upload_score()</tt></a> o <a href=
"../../../3_scripting/4_gml_reference/steam%20api/steam_upload_score_buffer.html"><tt>steam_upload_score_buffer()</tt></a> ) El retorno <tt>ds_map</tt> Tendrá los siguientes pares clave / valor: <br><br><ul><li> &quot; <b>event_type</b> &quot;: esta clave mantendrá el valor &quot; <b>leaderboard_upload</b> &quot; </li><li style="list-style: none"><br></li><li> &quot; <b>post_id</b> &quot;: esta clave debe coincidir con el valor de ID devuelto por la función de carga de llamadas </li><li style="list-style: none"><br></li><li> &quot; <b>lb_name</b> &quot;: esta clave contiene el nombre de la tabla de clasificación que se envió a </li><li style="list-style: none"><br></li><li> &quot; <b>success</b> &quot; - Será 1 si la publicación tuvo éxito, 0 falló </li><li style="list-style: none"><br></li><li> &quot; <b>actualizado</b> &quot;: será 1 si la puntuación de la tabla de clasificación se actualizó realmente (es decir, la nueva puntuación fue mejor) o 0 de lo contrario </li><li style="list-style: none"><br></li><li> &quot; <b>puntuación</b> &quot;: esta tecla contiene la puntuación que se publicó. </li></ul> Puede ver ejemplos de esto en las páginas para las funciones de carga de puntuación. </div><br><a name="async_steam_downloading" id="async_steam_downloading"></a> <label class="collapse" for="twentyfour">Descarga de tablas de clasificación</label> <input id="twentyfour" type="checkbox"><div class="index_list"> Cuando se utilizan las funciones de <span class="notranslate">Steam</span> para descargar una tabla de clasificación ( <a href=
"../../../3_scripting/4_gml_reference/steam%20api/steam_download_scores.html"><tt>steam_download_scores()</tt></a>, <a href=
"../../../3_scripting/4_gml_reference/steam%20api/steam_download_scores_around_user.html"><tt>steam_download_scores_around_user()</tt></a> o <a href=
"../../../3_scripting/4_gml_reference/steam%20api/steam_download_friends_scores.html"><tt>steam_download_friends_scores()</tt></a> ) El retorno <tt>ds_map</tt> Tendrá los siguientes pares clave / valor: <br><br><ul><li> &quot; <b>event_type</b> &quot;: esta clave mantendrá el valor &quot; <b>leaderboard_download</b> &quot; </li><li style="list-style: none"><br></li><li> &quot; <b>id</b> &quot;: esta clave debe coincidir con el valor de ID devuelto por la función de descarga de llamadas </li><li style="list-style: none"><br></li><li> &quot; <b>estado</b> &quot;: el estado de la devolución de llamada, donde -1 equivale a una falla o no se devolvió ningún resultado, y 0 equivale a un éxito. </li><li> &quot; <b>lb_name</b> &quot;: esta clave contiene el nombre de la tabla de clasificación que se envió a </li><li style="list-style: none"><br></li><li> &quot; <b>numEntries</b> &quot;: el número de &quot;filas&quot; de datos de la tabla de clasificación que se devuelven. </li><li style="list-style: none"><br></li><li> &quot; <b>entries</b> &quot; - Una cadena de objeto JSON que contiene otro ds_map, que contendrá la clave &quot;default&quot; (lo que significa que no hay resultados dentro) o la clave &quot;entries&quot;, de la que puede obtener el valor. este valor devuelto para &quot;entradas&quot; será un <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20lists/index.html"><tt>ds_list</tt></a> que contiene cada uno de los rangos de la tabla de clasificación, donde cada entrada en la lista se referirá a otra <tt>ds_map</tt> que contendrá las claves &quot;nombre&quot;, &quot;puntuación&quot; y &quot;rango&quot;, y también puede contener una clave de &quot;datos&quot; dependiendo de la función utilizada para cargar. </li></ul> Mostraremos un ejemplo de cómo funciona la descarga de datos de puntuación al solicitar los diez primeros puestos para la tabla de clasificación determinada y al analizar sus resultados en el <b>Evento Async de <span class="notranslate">Steam</span></b> (para cargar ejemplos, consulte las páginas de funciones correspondientes). Para empezar necesitamos solicitar los puntajes con el siguiente código: <br><br><p class="code">score_get = steam_download_scores("Game Scores", 1,
10);<br><span class="notranslate"></span></p><br> Esto enviará una solicitud al Servidor <span class="notranslate">Steam</span> para obtener las puntuaciones de la tabla de clasificación &quot;Puntuaciones del juego&quot;, almacenando el <b>ID asíncrono</b> de la solicitud en la variable &quot;score_get&quot;. Esto se manejará en el <b>evento <span class="notranslate">Steam</span> Async</b> de la siguiente manera: <br><br><p class="code">var async_id = ds_map_find_value(async_load,
"id");<br>
if async_id == score_get<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;var entries = ds_map_find_value(async_load,
"entries");<br>
&nbsp;&nbsp;&nbsp;var map = json_decode(entries);<br>
&nbsp;&nbsp;&nbsp;if ds_map_exists(map, "default")<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ds_map_destroy(map);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var list =
ds_map_find_value(map, "entries");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var len =
ds_list_size(list);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var entry;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(var i = 0; i &lt; len;
i++;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entry =
ds_list_find_value(list, i );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;steam_name[i]
= ds_map_find_value(entry, "name");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;steam_score[i]
= ds_map_find_value(entry, "score");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;steam_rank[i]
= ds_map_find_value(entry, "rank");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(ds_map_exists(entry, "data"))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var
data = ds_map_find_value(entry, "data");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var
buffId = buffer_base64_decode(data);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var
message = buffer_read(buffId, buffer_string);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;show_debug_message(
" -- attached message: " + string(message));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer_delete(buffId);<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ds_map_destroy(entry);<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ds_list_destroy(list)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;ds_map_destroy(map)<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> Lo que hacemos aquí es primero comprobar la clave &quot;id&quot; de la especial <tt>async_load</tt> mapa. Si este valor es el mismo que el valor de la función de devolución de llamada original (almacenada en la variable &quot;score_get&quot;), continuamos procesando los datos. Lo primero que hacemos es analizar el <tt>async_load</tt> ds_map para las &quot;entradas&quot; clave que contendrán un objeto JSON que contiene los datos de la tabla de clasificación. Este objeto JSON se decodifica (ver <a href=
"../../../3_scripting/4_gml_reference/file%20handling/json_decode.html"><tt>json_decode</tt></a> ) como otro ds_map, y este nuevo ID de mapa se almacena en la variable &quot;mapa&quot;. <br><br> Este mapa se comprueba para la clave &quot;predeterminada&quot; y si se encuentra, se destruye el mapa y se sale del evento. Si no se encuentra una clave &quot;predeterminada&quot;, el código analizará el mapa para extraer la información necesaria sobre la tabla de clasificación, extrayendo primero un ds_list de la clave de &quot;entradas&quot; del ds_map, y luego repasando cada entrada de la lista para obtenga <i>otro</i> ds_map con el nombre, puntaje y rango de cada entrada. Estos valores luego se almacenan en arreglos y luego verificamos si hay una clave de &quot;datos&quot; adicional. Si existe (es decir, la puntuación se cargó con un paquete de datos adicional), entonces también lo analizamos y lo enviamos a la consola del compilador para su depuración, antes de destruir el búfer y luego continuar destruyendo el mapa. Tenga en cuenta que si se incluye la clave de &quot;datos&quot;, debe decodificarse utilizando el <a href=
"../../../3_scripting/4_gml_reference/buffers/buffer_base64_decode.html"><tt>buffer_base64_decode()</tt></a> antes de que se pueda leer correctamente. <br><br> Una vez que el bucle ha finalizado, la lista de entradas se destruye al igual que el mapa del que se tomó. No hay necesidad de destruir el <tt>async_load</tt> ds_map ya que esto lo maneja <i><span class="notranslate">GameMaker Studio 2</span></i>. </div><br><a name="async_steam_downloadingugc" id=
"async_steam_downloadingugc"></a> <label class="collapse" for=
"twentyfive">Descargando UGC (contenido generado por el usuario)</label> <input id="twentyfive" type="checkbox"><div class="index_list"> Cuando se usan las funciones de <span class="notranslate">Steam</span> para descargar <a href=
"../../../3_scripting/4_gml_reference/steam%20api/user%20generated%20content/index.html">contenido generado</a> por el <a href=
"../../../3_scripting/4_gml_reference/steam%20api/user%20generated%20content/index.html">usuario (UGC)</a>, varios de ellos activarán este evento. Sin embargo, cada función generará un <tt>async_load</tt> ds_map con diferentes pares clave / valor (aunque siempre contendrán las claves generales &quot; <b>id</b> &quot;, &quot; <b>result</b> &quot; y &quot; <b>event_type</b> &quot;), así que consulte la página específica de la función que se está usando para obtener detalles y ejemplos. </div><br><a name="async_steam_ugc_events" id="async_steam_ugc_events"></a> <label class="collapse" for="twentysix">Eventos únicos de UGC</label> <input id="twentysix" type="checkbox"><div class="index_list"> El evento <span class="notranslate">Steam</span> Async también se puede activar cuando un usuario se suscribe a un elemento fuera del juego; por ejemplo, se separan de un navegador y se suscriben a un nuevo elemento y luego regresan al juego. En estos casos los <tt>async_load</tt> el mapa <b>solo</b> contendrá los siguientes detalles (y ninguno de los valores predeterminados que figuran en la parte superior de esta página): <br><br><ul><li> &quot; <b>event_type</b> &quot;: esta clave mantendrá el valor &quot; <b>ugc_item_installed</b> &quot; </li><li style="list-style: none"><br></li><li> &quot; <b>publish_file_id</b> &quot;: el ID del elemento UGC recién instalado (puede usar la función <a href=
"../../../3_scripting/4_gml_reference/steam%20api/user%20generated%20content/steam_ugc_get_item_install_info.html"><tt>steam_ugc_get_item_install_info()</tt></a> para obtener la ruta al elemento instalado) </li><li style="list-style: none"><br></li></ul> El evento <span class="notranslate">Steam</span> Async también se puede activar cuando se suscribe un elemento del taller, ya sea desde dentro de la aplicación o desde un navegador del taller, y en estos casos el <tt>async_load</tt> El mapa contendrá los siguientes pares clave / valor: <br><br><ul><li> &quot; <b>event_type</b> &quot;: esta clave mantendrá el valor &quot; <b>ugc_item_subscribed&quot;</b> &quot; </li><li style="list-style: none"><br></li><li> &quot; <b>publish_file_id</b> &quot;: esta clave tiene el ID de archivo publicado del artículo recién suscrito </li><li style="list-style: none"><br></li></ul> El evento se activará en caso de que también se cancele la suscripción de cualquier elemento, con el mapa de DS que contenga lo siguiente: <br><br><ul><li> &quot; <b>event_type</b> &quot;: esta clave mantendrá el valor &quot; <b>ugc_item_unsubscribed&quot;</b> &quot; </li><li style="list-style: none"><br></li><li> &quot; <b>publish_file_id</b> &quot;: esta clave tiene el ID de archivo publicado del elemento no suscrito </li><li style="list-style: none"><br></li></ul></div></blockquote></div><br><a name="async_system" id="async_system"></a> <label class=
"collapse" for="fourteen">Sistema</label> <input id="fourteen" type=
"checkbox"><div class="index_list"><p> Este evento solo puede ser activado por un evento a nivel del sistema (como la detección de un gamepad o el inicio de sesión automático en XBox Live) y devolverá un <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> almacenado en la variable <tt>async_load</tt>, que contiene diferentes pares clave / valor en función del evento a nivel del sistema que activó la devolución de llamada. </p><blockquote><a name="async_system_gamepads" id=
"async_system_gamepads"></a> <label class="collapse" for=
"thirtyone">Almohadillas de juego</label> <input id="thirtyone" type=
"checkbox"><div class="index_list"><p> Cuando este evento se activa para que un gamepad se conecte o desconecte, devolverá uno de los siguientes pares de clave / valor en el <tt>async_load</tt> mapa: <br><br></p><ul><li> &quot; <b>event_type</b> &quot;: el tipo de evento del sistema recibido, que será una de las siguientes cadenas: <br><br><ul><li> &quot; <b>gamepad descubierto</b> &quot;: sucede cuando el sistema informa que se ha conectado un nuevo gamepad </li><li> &quot; <b>gamepad perdido</b> &quot;: sucede cuando el sistema ha perdido la conexión con un gamepad </li></ul></li><li> &quot; <b>pad_index</b> &quot;: el índice del pad que se ha agregado o eliminado </li></ul><p> Este evento ahora le permite mover toda la lógica de verificación de su gamepad desde el Evento de Paso o un evento de Alarma al Evento del Sistema y solo ejecutarlo cuando sea realmente necesario. </p></div><br><a name="async_system_gamepads" id="async_system_gamepads"></a> <label class="collapse" for="thirtythree">Teclados virtuales</label> <input id="thirtythree" type="checkbox"><div class="index_list"><p> Cuando se desencadena este evento para abrir o cerrar un teclado virtual, se devolverán los siguientes pares de clave / valor en el <tt>async_load</tt> mapa: <br><br></p><ul><li> &quot; <b>event_type</b> &quot;: el tipo de evento del sistema recibido, que será el &quot; <b>estado del teclado virtual</b> &quot; para los teclados virtuales. </li><li style="list-style: none"><br></li><li> &quot; <b>screen_height</b> &quot;: la altura del teclado virtual (en píxeles). Esto será 0 si el teclado es invisible. </li><li style="list-style: none"><br></li><li> &quot; <b>keyboard_status</b> &quot;: el estado actual del teclado, devuelto como una de las siguientes cadenas: <br><br><ul><li> &quot;ocultación&quot; </li><li> &quot;oculto&quot; </li><li> &quot;demostración&quot; </li><li> &quot;visible&quot; </li></ul></li></ul><p> Vea <a href=
"../../../3_scripting/4_gml_reference/controls/virtual%20keys/index.html">aquí</a> para más información sobre el teclado virtual. </p></div><br><a name="async_system_xboxlive" id="async_system_xboxlive"></a> <label class="collapse" for="thirtytwo">Xbox Live</label> <input id="thirtytwo" type="checkbox"><div class="index_list"><p> El evento del sistema asíncrono se puede activar cuando se dirige a la <b><span class="notranslate">XBox One</span></b> utilizando la exportación de <b>UWP</b> y marcando la opción <b>Activar XBox Live</b> en las <a href=
"../../../2_interface/3_settings/game_options/options_windowsuwp.html">Opciones de juego de</a> la <a href=
"../../../2_interface/3_settings/game_options/options_windowsuwp.html">UWP</a>. Cuando inicie el proyecto de <i><span class="notranslate">GameMaker Studio 2</span></i> UWP que tiene Xbox Live habilitado, el proyecto intentará automáticamente iniciar sesión de forma silenciosa en Xbox Live. Los resultados de este intento de inicio de sesión se devolverán como uno de los siguientes pares clave / valor en el <tt>async_load</tt> mapa: </p><ul><li> &quot; <b>event_type</b> &quot;: el tipo de evento del sistema recibido, que será una de las siguientes cadenas: <br><br><ul><li> &quot; <b>usuario</b> iniciado sesión&quot;: el inicio de sesión silencioso del usuario se ha completado correctamente </li><li> &quot; <b>inicio de sesión de usuario fallido</b> &quot;: el inicio de sesión silencioso del usuario ha fallado (cuando esto sucede, puede usar la función <a href=
"../../../3_scripting/4_gml_reference/xbox_live/xboxlive_show_account_picker.html"><tt>xboxlive_show_account_picker()</tt></a> para obtener el usuario para elegir una cuenta para iniciar sesión con) </li><li> &quot; <b>usuario desconectado</b> &quot;: el usuario ha cerrado sesión </li></ul></li></ul><p> Para obtener más información sobre las funciones específicas disponibles para XBox Live, consulte <a href=
"../../../3_scripting/4_gml_reference/xbox_live/index.html">aquí</a>. </p></div></blockquote></div></blockquote><p><br></p></div><div class="footer"><div class="buttons"><div class="clear"><div style="float:left"> Atrás: <a href="../objects.html">El editor de objetos</a> </div><div style="float:right"> Siguiente: <a href="draw_events.html">Dibuja Eventos</a> </div></div></div><h5>© Copyright YoYo Games Ltd. 2018 All Rights Reserved</h5>
<script type="text/javascript">
   (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');   ga('create', 'UA-2711665-14', 'auto');   ga('send', 'pageview'); 
</script>
</div>

<script type="text/JavaScript">
var fe = FindFrame("toc", top);
if ((fe != null) && (chmtop.c2wtopf.jstree != null)) {
  if (chmtop.c2wtopf.FITEMS[chmtop.c2wtopf.pagenum] != chmtop.c2wtopf.pageid)
    chmtop.c2wtopf.jstree.OpenTreeNode("source/" + chmtop.c2wtopf.pageid);
}
</script>
</body>
</html>

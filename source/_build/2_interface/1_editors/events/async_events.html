<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="keywords" content="online documentation, web online help, web help, chm2web" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="generator" content="chm2web Pro 2.85 (unicode)" />
<title>The Asynchronous Events</title>
<meta http-equiv="X-UA-Compatible" content="IE=9">

<link rel="stylesheet" href="../../../../../files/helpindex.css"
type="text/css">
<link rel="stylesheet" href="../../../../../default.css" type=
"text/css">

<script type="text/JavaScript" src="../../../../../files/supply.js"></script>
<script type="text/JavaScript">
chmtop.c2wtopf.pageid = "_build/2_interface/1_editors/events/async_events.html";
</script>

</head>
<body><script type="text/JavaScript"> 
if (window.name != "content") 
  document.write(" <table width=\"100%\" bgcolor=\"#e1e1e1\"cellspacing=\"2\" cellpadding=\"0\" style=\"border-collapse: collapse; font-family: sans-serif; font-size: 14px; color: #000000; text-decoration: none;  \"> <tr> <td align=\"center\" style=\"border-bottom: 2px solid gray\" > <br>&nbsp;Click <a href=\"../../../../../index.html?page=source%2F_build%2F2_interface%2F1_editors%2Fevents%2Fasync_events.html\">here</a> to show toolbars of the Web Online Help System: <a href=\"../../../../../index.html?page=source%2F_build%2F2_interface%2F1_editors%2Fevents%2Fasync_events.html\">show toolbars</a><br>&nbsp;</td></tr></table><br> "); 
</script>
<!-- !chm2web! --><script type="text/JavaScript">
 if( typeof(chmtop.helpStyle) != 'undefined' ) { var linkNodes = document.getElementsByTagName("link");  for( var i=0; i < linkNodes.length; ++i ) { var link = linkNodes[i];    if( link.href.endsWith("default.css")) {    var style = link.href.replace("default.css", chmtop.helpStyle); document.write('<link id="newstyleLink" rel="stylesheet" href=' + style + ' type="text/css">');    break; } } } 
</script><h2> Los eventos asíncronos </h2><div class="body-scroll"><p><img class="center" src="images/editor_objects_async.png" alt="Eventos asincrónicos del editor de objetos"> Un <b>evento asíncrono</b> es aquel que se dispara cuando <i><span class="notranslate">GameMaker Studio 2</span></i> recibe una &quot;devolución de llamada&quot; de alguna fuente externa, que puede ser desde la web o desde el dispositivo que ejecuta su juego. Básicamente, le dices a <i><span class="notranslate">GameMaker</span> Studio 2</i> que haga algo, como cargar una imagen, y comenzará a hacer esto, pero continuará haciendo lo que sea que tenga que hacer mientras esté funcionando. Luego, cuando se complete la solicitud, se enviará una devolución de llamada a <i><span class="notranslate">GameMaker Studio 2</span></i> y se <b>activarán los eventos asincrónicos</b> definidos para ese tipo de devolución de llamada. Tenga en cuenta que los eventos asincrónicos se activan para <i>todas las</i> instancias que los tienen, al igual que los eventos clave, para que pueda hacer un <tt>http_get</tt> llamar en una instancia, pero tener el evento HTTP asíncrono en otro para tratar la devolución de llamada. <br></p><div class="note"> <b>NOTA</b>: Debe tener en cuenta que debido a la protección XSS en los navegadores, las solicitudes e intentos de cargar recursos desde varios dominios están bloqueadas y puede parecer que devuelven resultados en blanco al usar cualquiera de los siguientes eventos. </div><p><br> Hay varios tipos de eventos asociados con la categoría de evento asincrónico, y todos se explican en las siguientes secciones: </p><div class="note"> <b>NOTA:</b> la variable <tt>async_load</tt> que se menciona en las siguientes secciones <b>solo</b> es <b>válido en estos eventos</b>, ya que <tt>ds_map</tt> es decir, los puntos se crean al comienzo del evento, luego se eliminan nuevamente al final, y esta variable se restablece a un valor de -1 en todos los demás momentos. </div><p><br></p><blockquote><a name="async_audio_play" id="async_audio_play"></a> <label class="collapse" for="thirteen">Reproducción de audio</label> <input id="thirteen" type="checkbox"><div class="index_list"> Este evento solo puede ser activado por las <a href=
"../../../3_scripting/4_gml_reference/audio/audio%20buffers.html">funciones de reproducción de la cola de audio</a> y devolverá un <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> almacenado en la variable <tt>async_load</tt>, que contiene diferentes pares clave / valor relacionados con la cola de audio que ha activado el evento. El evento se activa cuando ha seleccionado una cola de audio para la reproducción y un búfer en esa cola de audio se termina de reproducir. <br><br> Las siguientes claves estarán disponibles en el ds_map: <br><br><ul><li> &quot; <b>queue_id</b> &quot;: el índice de cola para la cola que se ha terminado de reproducir, tal como lo devuelve la función <a href=
"../../../3_scripting/4_gml_reference/audio/audio_create_play_queue.html"><tt>audio_create_play_queue</tt></a>. </li><li> &quot; <b>buffer_id</b> &quot;: la identificación del buffer para el buffer que ya no se reproduce desde </li><li> &quot; <b>queue_shutdown</b> &quot;: se establece en 0 durante la reproducción normal y 1 cuando se recibe el evento porque <a href=
"../../../3_scripting/4_gml_reference/audio/audio_free_play_queue.html"><tt>audio_free_play_queue</tt></a> ha sido llamado. Cuando se establece en 1, no desea poner en cola ningún dato adicional. </li></ul> Dado que se puede crear una cola de audio a partir de múltiples búferes, este evento se puede activar varias veces para una cola, ya que se llega al final de cada sección de audio almacenado, de ahí la tecla &quot;buffer_id&quot;. <br><br><div class="note"> <b>NOTA:</b> la variable <tt>async_load</tt> solo es válido en los eventos asíncronos, como <tt>ds_map</tt> es decir, los puntos se crean al comienzo del evento, luego se eliminan nuevamente al final, con esta variable se restablece a un valor de -1. Sin embargo, todas las demás estructuras de datos creadas a partir del evento se <b>deben limpiar utilizando las funciones apropiadas</b>. </div><br> En el ejemplo de uso que se proporciona a continuación, crearemos una cola de audio con 10 sonidos de audio en búfer añadidos y luego reproduciremos la cola: <br><br><p class="code">audio_queue = audio_create_play_queue(buffer_s16,
11052, audio_mono);<br>
for (var i = 0; i &lt; 10; i++;)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;audio_queue_sound(audio_queue, audio_buffer[i],
0, buffer_get_size(audio_buffer[i]));<br>
&nbsp;&nbsp;&nbsp;}<br>
audio_play_sound(audio_queue, 0, true);<br><span class="notranslate"></span></p><br> Cada paso del juego ahora que se detecta la grabación activará un evento de grabación de audio asíncrono en el que puede tratar con la entrada grabada algo como esto: <br><br><p class="code">var queue = async_load[? "queue_id"];<br>
var num = 0;<br>
if queue = audio_queue<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;for (var i = 0; i &lt; 10; i++;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if async_load[? "buffer_id"] ==
audio_buffer[i]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer_seek(audio_buffer[i],
buffer_seek_start, 0);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num = i;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;if num == 9<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;audio_stop_sound(audio_queue);<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;audio_free_play_queue(audio_queue);<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> Aquí verificamos la identificación de la cola y si es la que queremos, luego verificamos la ID del búfer para ver qué búfer ha terminado de reproducirse. También establecemos una var local en ese valor de índice para verificar más adelante y restablecemos el búfer al comienzo de ese sonido. Una vez que nuestra variable local llega a 9, lo que indica que la cola ha finalizado, dejamos de reproducir el sonido y liberamos la cola. </div><br><a name="async_audio_rec" id="async_audio_rec"></a> <label class=
"collapse" for="twelve">Grabación de audio</label> <input id="twelve"
type="checkbox"><div class="index_list"> Este evento solo puede ser activado por <a href=
"../../../3_scripting/4_gml_reference/audio/audio_start_recording.html"><tt>audio_start_recording()</tt></a> función y devolverá un <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> almacenado en la variable <tt>async_load</tt>, que contiene diferentes pares de clave / valor dependiendo de la devolución de llamada de la función que ha desencadenado el evento. <br><br> Las siguientes claves estarán disponibles en el ds_map: <br><br><ul><li> &quot; <b>buffer_id</b> &quot;: el ID del búfer temporal que puede usar para recuperar los datos de audio </li><li> &quot; <b>channel_index</b> &quot;: el índice del canal de grabación devuelto por la función de llamada del que provienen estos datos </li><li> &quot; <b>data_len</b> &quot;: la longitud de los datos (en bytes) que ha recibido </li></ul><div class="note"> <b>NOTA:</b> Como se mencionó al comienzo de esta página, la variable <tt>async_load</tt> solo es válido en los eventos asíncronos, como <tt>ds_map</tt> es decir, los puntos se crean al comienzo del evento, luego se eliminan nuevamente al final. Sin embargo, tenga en cuenta que el búfer temporal en el que se almacena todo el audio con el mapa también se eliminará al final del evento, por lo que debe copiarlo en un búfer personalizado si desea mantenerlo para su uso posterior. </div><br> En el siguiente ejemplo de uso crearemos un búfer personalizado para almacenar nuestro audio grabado, y también configuraremos nuestro juego para grabar desde la fuente de entrada 0: <br><br><p class="code">channel_index = audio_start_recording(0);<br>
audio_buffer = buffer_create(len, buffer_fast, 1);<br><span class="notranslate"></span></p><br> Cada paso del juego ahora que se detecta la grabación activará un evento de grabación de audio asíncrono en el que puede tratar con la entrada grabada algo como esto: <br><br><p class="code">var channel = async_load[? "channel_index"];<br>
if channel == channel_index<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;len = async_load[? "data_len"];<br>
&nbsp;&nbsp;&nbsp;buffer_copy(async_load[? "buffer_id"], 0, len,
audio_buffer, 0);<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> Aquí simplemente verificamos la clave &quot;channel_index&quot; para asegurarnos de que coincida con el valor devuelto cuando comenzamos a grabar, y si lo hace, copiamos el contenido del búfer temporal creado para este evento en nuestro búfer personalizado. Después de eso, puede hacer lo que quiera con el búfer personalizado: puede reproducirlo utilizando las funciones de búfer dedicadas de audio, puede procesarlo y enviarlo a través de la red, puede guardarlo en el disco... Una vez que tenga su audio grabado en un buffer, puedes hacer básicamente lo que quieras. </div><br><a name="async_cloud" id="async_cloud"></a> <label class="collapse"
for="five">Nube</label> <input id="five" type="checkbox"><div class="index_list"> El Cloud Event es uno que se desencadena por la devolución de llamada de uno de los <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/index.html"><tt>cloud_</tt> funciones</a>, como <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/cloud_synchronise.html"><tt>cloud_synchronise</tt></a>. En realidad genera un <tt>ds_map</tt> eso es exclusivo de este evento y se almacena en la variable especial <b>async_load</b> (consulte las funciones individuales para ejemplos de código que explican el uso de este evento con más detalle). Este ds_map tiene la siguiente estructura: <br><br><ul><li> <b>&quot;estado&quot;:</b> contiene el código de estado, donde un valor negativo denota un error, cuya descripción se incluirá en &quot;errorString&quot;. Un valor de 0 (o un valor positivo) indica un éxito (ver a continuación los valores exactos), y &quot;resultString&quot; contendrá los datos devueltos o un mensaje de éxito. </li><li style="list-style: none"><br></li><li> <b>&quot;id&quot;:</b> Id. que se devolvió de la función llamada. Si disparas una serie de <tt>cloud_</tt> Luego, debe saber a cuál le está respondiendo y, por lo tanto, debe usar este valor para compararlo con el valor que guardó cuando envió originalmente la solicitud para encontrar el correcto. </li><li style="list-style: none"><br></li><li> <b>&quot;descripción&quot;:</b> la descripción del último archivo cargado. </li><li style="list-style: none"><br></li><li> <b>&quot;resultString&quot;:</b> Esto contiene una cadena que es el blob de datos devuelto por la nube. </li><li style="list-style: none"><br></li><li> <b>&quot;errorString&quot;:</b> devuelve una cadena de error para cualquier error. </li></ul> El significado exacto de la entrada del mapa &quot;estado&quot; devuelto se explica en la siguiente tabla: <div class="compat"><table><tr><th> Valor de estado </th><th> errorString / resultString </th><th> Descripción </th></tr><tr><td> <span class="notranslate">-1</span> </td> <td> errorString = &quot;No ha iniciado sesión en &lt;SERVICE&gt;&quot; </td><td> <span class="notranslate">You have not successfully logged in to the given Cloud Service</span> </td> </tr><tr class="alt"><td> <span class="notranslate">0</span> </td> <td> resultString = datos recuperados </td><td> <span class="notranslate">New game data downloaded from the cloud (following a cloud_synchronise call)</span> </td> </tr><tr><td> <span class="notranslate">1</span> </td> <td> resultString = &quot;Ya sincronizado&quot; </td><td> <span class="notranslate">No new data since you last called cloud_synchronise</span> </td> </tr><tr class="alt"><td> <span class="notranslate">2</span> </td> <td> resultString = &quot;ConflictDeferral&quot; </td><td> <span class="notranslate">A conflict was encountered, but the gamer chose to ignore it</span> </td> </tr><tr><td> <span class="notranslate">3</span> </td> <td> resultString = &quot;GameUploadSuccess&quot; </td><td> <span class="notranslate">data from <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/cloud_string_save.html"><tt>cloud_string_save</tt></a> or <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/cloud_file_save.html"><tt>cloud_file_save</tt></a> was successfully uploaded to the cloud</span> </td> </tr><tr class="alt"><td> <span class="notranslate">-n</span> </td> <td> errorString = Descripción del error </td><td> <span class="notranslate">Any other negative number means a synchronisation failure</span> </td> </tr></table></div></div><br><a name="async_dialogue" id="async_dialogue"></a> <label class=
"collapse" for="three">Diálogo</label> <input id="three" type=
"checkbox"><div class="index_list"> Al igual que los eventos anteriores, el evento <b>Dialogos</b> solo se activa cuando recibe una llamada de una de las funciones asíncronas especiales del usuario, como <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/get_login_async.html"><tt>get_login_async()</tt></a> (Consulte esta función para obtener un ejemplo de código extendido de cómo se usa este evento). Estos eventos son los que solicitan algún tipo de entrada de usuario, que puede ser un nombre, detalles de inicio de sesión, un número o un color, etc.... Como a la mayoría de los dispositivos no les gusta sentarse en un bucle esperando una respuesta, tienen que <i><span class="notranslate">GameMaker Studio 2</span></i> asincrónico y <i><span class="notranslate">GameMaker Studio 2</span></i> continuará ejecutándose en segundo plano mientras estas funciones tengan un diálogo abierto y hasta que obtengan la entrada de usuario requerida que desencadena este evento. <br><br> De nuevo, una <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> se devuelve con el id. contenido en la variable especial <b>async_load</b>. Los valores contenidos en este mapa dependerán de la función utilizada, y debe consultar las entradas individuales para cada función en este manual para obtener más detalles. </div><br><a name="async_http" id="async_http"></a> <label class="collapse"
for="two">HTTP</label> <input id="two" type="checkbox"><div class="index_list"> El evento HTTP es uno que se desencadena por la devolución de llamada de uno de los <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/index.html"><tt>http_</tt> funciones</a>, como <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/http_post_string.html"><tt>http_post_string</tt></a>. En realidad genera un <tt>ds_map</tt> (a veces conocido como un &quot;diccionario&quot;) que es exclusivo de este evento y se almacena en la variable especial <tt>async_load</tt> (Consulte las funciones individuales para ejemplos de códigos que explican el uso de este evento con más detalle). Esta <tt>ds_map</tt> tiene la siguiente estructura: <br><br><ul><li> <b>&quot;id&quot;:</b> la id que se devolvió desde el comando. Si disparas una serie de <tt>http_</tt> Luego, debe saber a cuál le está respondiendo y, por lo tanto, debe usar este valor para compararlo con el valor que guardó cuando envió originalmente la solicitud para encontrar el correcto. </li><li style="list-style: none"><br></li><li> <b>&quot;estado&quot;:</b> devuelve un valor de menos de 0 para un error, 0 para el éxito y 1 si el contenido se está descargando. </li><li style="list-style: none"><br></li><li> <b>&quot;resultado&quot;:</b> los datos recibidos (solo cadena) o la ruta al archivo descargado si ha utilizado <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/http_get_file.html"><tt>http_get_file()</tt></a>. </li><li style="list-style: none"><br></li><li> <b>&quot;url&quot;:</b> la URL completa que solicitó. </li><li style="list-style: none"><br></li><li> <b>&quot;http_status&quot;:</b> el código de estado HTTP sin procesar (si está disponible). Esto devuelve el código de estado web estándar para la mayoría de los navegadores, por ejemplo: 304 para &quot;No modificado&quot; o 204 para &quot;Sin contenido&quot;, etc. </li></ul> Eso es para cuando usas el <tt>http_post_string()</tt> función, pero cada uno de los <tt>http_</tt> las funciones pueden devolver un mapa ligeramente diferente, por lo tanto, consulte la entrada manual de cada función para encontrar los datos precisos que se devuelven. <br><br><div class="note"> <b>NOTA:</b> Como <tt>async_load</tt> crea un <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a>, estas funciones son particularmente útiles cuando se combinan con <a href=
"../../../3_scripting/4_gml_reference/file%20handling/json_encode.html"><tt>json_encode</tt></a> y <a href=
"../../../3_scripting/4_gml_reference/file%20handling/json_decode.html"><tt>json_decode</tt></a> funciones. </div><br><br> También podría haber datos adicionales proporcionados por este mapa si ha solicitado archivos para descargar. En este caso, el &quot;estado&quot; tendrá un valor de 1 y el ds_map tendrá estas claves adicionales: <br><br><ul><li> <b>&quot;contentLength&quot;:</b> este es el tamaño del archivo que el servidor web ha dicho que debe esperar recibir (puede ser -1 si el servidor no devuelve estos datos). </li><li style="list-style: none"><br></li><li> <b>&quot;sizeDownloaded&quot;:</b> el tamaño de los datos que ya se han descargado. </li></ul> Tenga en cuenta que el evento <i>no</i> se activará para cada paquete de datos que se reciba, sino que se actualizará en cualquier momento durante la descarga dentro del ciclo principal del juego. También tenga en cuenta que actualmente esta funcionalidad solo está disponible para las plataformas de destino de <i>Windows</i> normales. </div><br><a name="async_iap" id="async_iap"></a> <label class="collapse"
for="four">IAP</label> <input id="four" type="checkbox"><div class="index_list"> Este evento solo se puede activar cuando hayas activado <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/index.html">Compras en aplicaciones</a> para tu juego. Si tiene esta funcionalidad agregada, el evento se activará en las siguientes circunstancias: <br><br><ul><li> El estado de la tienda cambia. </li><li> Un producto (o productos) ha sido activado. </li><li> El producto y las compras han sido restaurados. </li><li> Un producto ha sido comprado. </li><li> Un producto ha sido consumido </li></ul> El evento siempre creará un especial <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> con un ID de índice almacenado en la variable incorporada <tt><b>iap_data</b></tt>. Este mapa <i>siempre</i> contendrá la clave &quot; <b>tipo</b> &quot;, que mantendrá uno de los siguientes valores constantes: <div class="compat"><table><tr><th> Constante </th><th> Descripción </th></tr><tr><td> <span class="notranslate">iap_ev_storeload</span> </td> <td> Esto se activa cuando se detecta un cambio en la tienda de la plataforma objetivo. </td></tr><tr class="alt"><td> <span class="notranslate">iap_ev_product</span> </td> <td> Este evento se activa cuando un producto está activado y contendrá información adicional sobre el producto. </td></tr><tr><td> <span class="notranslate">iap_ev_restore</span> </td> <td> Este evento solo se desencadena cuando usas el <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_restore_all.html"><tt>iap_restore_all</tt></a> función. </td></tr><tr class="alt"><td> <span class="notranslate">iap_ev_purchase</span> </td> <td> Cuando se completa una compra, este evento se desencadena. </td></tr><tr><td> <span class="notranslate">iap_ev_consume</span> </td> <td> Cuando usas la función <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_consume.html"><tt>iap_consume</tt></a> desencadena este evento. </td></tr></table></div><p><br><br> Cada uno de estos posibles &quot;tipos&quot; de eventos agregará claves adicionales al <tt>iap_data</tt> ds_map, que luego se puede analizar para obtener la compra o la información del producto necesaria. El contenido exacto de la <tt>iap_data</tt> mapa se enumeran a continuación para cada evento &quot;tipo&quot;. </p><blockquote><a name="iap_ev_storeload" id="iap_ev_storeload"></a> <label class="collapse" for="fifteen">iap_ev_storeload</label> <input id="fifteen" type="checkbox"><div class="index_list"> Cuando active sus compras, su juego intentará ponerse en contacto con la tienda objetivo, lo que desencadenará este evento en el proceso. los <tt>iap_data</tt> el mapa tendrá una clave de adición &quot; <b>estado&quot;</b>, que tendrá una de las siguientes constantes a medida que su valor sea: <br><br><div class="compat"><table><tr><th> Constante </th><th> Descripción </th></tr><tr><td> <span class="notranslate">iap_storeload_ok</span> </td> <td> La tienda ha sido contactada y la conexión es buena. </td></tr><tr class="alt"><td> <span class="notranslate">iap_storeload_failed</span> </td> <td> Ha habido un error de conexión o, por alguna razón, la tienda no está disponible. </td></tr></table></div></div><br><a name="iap_ev_product" id="iap_ev_product"></a> <label class=
"collapse" for="sixteen">iap_ev_product</label> <input id="sixteen"
type="checkbox"><div class="index_list"> Todas las compras activadas activarán este &quot;tipo&quot; de evento, pero solo una vez por compra, por lo que si activó diez productos, debe esperar que este evento se active diez veces. Si ha recibido este evento, el <tt>iap_data</tt> ds_map contendrá la clave adicional &quot; <b>índice</b> &quot; que contiene la <b>cadena</b> única de <b>identificación</b> del producto para el producto que se activará. Puede usar la función <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_product_details.html"><tt>iap_product_details</tt></a> junto con este ID de producto para obtener más información. <br><br><div class="note"> <b>NOTA:</b> Google Play ( <span class="notranslate">Android</span> ) solo puede solicitar detalles de los productos 20 a la vez, lo que puede generar tiempos de carga bastante largos para las aplicaciones con un número significativo de productos. </div></div><br><a name="iap_ev_restore" id="iap_ev_restore"></a> <label class=
"collapse" for="seventeen">iap_ev_restore</label> <input id=
"seventeen" type="checkbox"><div class="index_list"> Cuando llamas a la función <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_restore_all.html"><tt>iap_restore_all</tt></a> activará este evento, agregando una clave de &quot; <b>resultado</b> &quot; al <tt>iap_data</tt> ds_map. Esta clave mantendrá <tt>true</tt> o <tt>false</tt> para indicar si los datos de compra se han restaurado correctamente desde la tienda de destino. </div><br><a name="iap_ev_purchase" id="iap_ev_purchase"></a> <label class=
"collapse" for="eighteen">iap_ev_purchase</label> <input id=
"eighteen" type="checkbox"><div class="index_list"> Al solicitar una compra usando la función <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_acquire.html"><tt>iap_acquire</tt></a> este tipo de evento se activará. los <tt>iap_data</tt> ds_map tendrá el &quot; <b>índice</b> &quot; de clave adicional que contiene el valor único de <b>ID de compra</b> para el producto que se compra. Puede usar la función <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_purchase_details.html"><tt>iap_purchase_details</tt></a> junto con esta identificación de compra para obtener más información. <br><br><div class="note"> <b>NOTA:</b> si el producto comprado es consumible, <b>debe usarse</b> con <tt>iap_consume</tt> antes de que se pueda hacer una nueva compra. </div></div><br><a name="iap_ev_consume" id="iap_ev_consume"></a> <label class=
"collapse" for="nineteen">iap_ev_consume</label> <input id=
"nineteen" type="checkbox"><div class="index_list"> Cuando se usa la función <a href=
"../../../3_scripting/4_gml_reference/in%20app%20purchases/iap_consume.html"><tt>iap_consume</tt></a> este tipo de evento se activará. los <tt>iap_data</tt> ds_map tendrá la clave adicional &quot; <b>producto</b> &quot; que contiene la cadena única de <b>identificación</b> del producto para el producto que se está consumiendo. </div></blockquote></div><br><a name="async_image_loaded" id="async_image_loaded"></a> <label class="collapse" for="one">Imagen cargada</label> <input id=
"one" type="checkbox"><div class="index_list"> Este evento se activa cuando carga una imagen en <i><span class="notranslate">GameMaker Studio 2</span></i>, siempre que haya utilizado una URL o ruta válida con la función de archivo de carga correspondiente. Por ejemplo, supongamos que desea cargar una imagen de sprite y solo cambia el sprite actual de la instancia por el nuevo cuando se haya cargado. Bueno, tendrías algo así en un evento de creación o de alarma (por ejemplo): <p class="code">spr =
sprite_add("http://www.angusgames.com/game/background1.png", 0,
false, false, 0, 0);<span class="notranslate"></span></p><p> Esto comenzará a cargar la imagen en el dispositivo o en el navegador, pero <i>no</i> bloqueará <i><span class="notranslate">GameMaker Studio 2</span></i> mientras espera a que se cargue el archivo. En cambio, <i><span class="notranslate">GameMaker</span> Studio 2</i> seguirá funcionando normalmente hasta que se cargue la imagen y la devolución de llamada desencadenará el evento <b>Image Loaded</b>, donde <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> se crea y almacena en la variable especial <b>async_load</b>. El mapa contiene la siguiente información: </p><ul><li> <b>&quot;nombre de archivo&quot;:</b> la ruta completa al archivo que solicitó. </li><li style="list-style: none"><br></li><li> <b>&quot;id&quot;:</b> la identificación del recurso que ha cargado. Esta será la misma que la variable a la que le ha asignado el recurso. </li><li style="list-style: none"><br></li><li> <b>&quot;estado&quot;:</b> devuelve un valor de menos de 0 para un error. </li></ul><p> A continuación, asignaría la imagen recién cargada a un fondo en este evento. Lo anterior también es cierto para sprites y sonidos, con un ds_map generado para cada uno de estos recursos como se muestra arriba, y el siguiente ejemplo de código demuestra cómo se usaría la información devuelta en este evento: </p><p class="code">if ds_map_find_value(async_load, "id") == spr<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;if ds_map_find_value(async_load, "status") &gt;=
0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprite_index = spr<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><p> El código anterior primero verificará la identificación del ds_map que se ha creado, luego verificará el estado de la devolución de llamada. Si el valor es mayor o igual a 0 (éxito de señalización), el resultado de la devolución de llamada se usará para establecer el índice de fondo en la imagen recién cargada. </p></div><br><a name="async_networking" id="async_networking"></a> <label class=
"collapse" for="six">Redes</label> <input id="six" type=
"checkbox"><div class="index_list"> El evento de red es uno que se activará por cualquier tráfico de red entrante y está vinculado a las <a href=
"../../../3_scripting/4_gml_reference/networking/index.html">funciones de red</a>. Este evento genera un <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html">ds_map</a> especial que es exclusivo de este evento y se almacena en la variable especial <b>async_load</b>. Esta <tt>ds_map</tt> contendrá información diferente según el tipo de evento de red que la generó. <blockquote><a name="async_network_common" id=
"async_network_common"></a> <label class="collapse" for=
"twenty">Eventos de redes comunes</label> <input id="twenty" type=
"checkbox"><div class="index_list"> Las siguientes teclas son comunes a todas las funciones de red recibidas y siempre estarán presentes en <tt>async_load</tt> mapa: <br><br><ul><li> <b>&quot;tipo&quot;:</b> Esto tendrá una de las constantes enumeradas a continuación como su valor de retorno, y designa el tipo de evento de red. </li><li style="list-style: none"><br></li><li> <b>&quot;id&quot;:</b> el id del socket (un número real, como lo devuelven la función <a href=
"../../../3_scripting/4_gml_reference/networking/network_create_server.html">network_create_server</a> o <a href=
"../../../3_scripting/4_gml_reference/networking/network_create_socket.html">network_create_socket</a> ) que está recibiendo el evento. En la mayoría de los casos, la ID de socket devuelta es la ID del socket TCP o UDP que desencadenó el evento; sin embargo, si el evento se desencadena en un <i>servidor</i> y es un evento de datos (ver a continuación), el ID de socket es el del <i>cliente</i> que envió el datos. </li><li style="list-style: none"><br></li><li> <b>&quot;ip&quot;:</b> la dirección IP del socket (como una cadena). </li><li style="list-style: none"><br></li><li> <b>&quot;puerto&quot;:</b> el puerto asociado a la dirección IP (útil cuando se trabaja con UDP). </li></ul> Los posibles valores de retorno para la clave &quot;tipo&quot; pueden ser cualquiera de las tres constantes enumeradas a continuación: <div class="compat"><table><tr><th> Constante </th><th> Descripción </th></tr><tr><td> <span class="notranslate">network_type_connect</span> </td> <td> El evento fue desencadenado por una conexión. </td></tr><tr class="alt"><td> <span class="notranslate">network_type_disconnect</span> </td> <td> El evento fue desencadenado por una desconexión. </td></tr><tr><td> <span class="notranslate">network_type_data</span> </td> <td> El evento fue desencadenado por los datos entrantes. </td></tr><tr class="alt"><td> <span class="notranslate">network_type_non_blocking_connect</span> </td> <td> El evento fue desencadenado por una conexión configurada como no bloqueante (puede usar la función <a href=
"../../../3_scripting/4_gml_reference/networking/network_set_config.html"><tt>network_set_config()</tt></a> para esto). </td></tr></table></div></div><br><a name="async_network_connect" id="async_network_connect"></a> <label class="collapse" for="twentyone">Conectando / Desconectando</label> <input id="twentyone" type="checkbox"><div class="index_list"> Cuando tienes un evento del tipo <tt>network_type_connect</tt>, <tt>network_type_non_blocking_connect</tt> o <tt>network_type_disconnect</tt>, el <tt>async_load</tt> mapa tendrá las siguientes claves adicionales: <br><br><ul><li> <b>&quot;socket&quot;:</b> esta tecla mantendrá el id del conector de conexión / desconexión. </li><li style="list-style: none"><br></li><li> <b>&quot;succeeded&quot; (exitoso):</b> esta clave será 0 o 1, donde 0 significa que se agotó el tiempo de espera de la conexión y 1 significa que tuvo éxito y el socket está listo para usar. </li></ul> Vale la pena señalar que el evento de red no se activa en los <i>clientes</i> cuando el <i>servidor se</i> desconecta, y que ninguno de los <tt>network_type_*</tt> los eventos se activarán en los clientes cuando el servidor al que están conectados se desconecte, incluso si la conexión está basada en TCP. </div><br><a name="async_network_receive" id="async_network_receive"></a> <label class="collapse" for="twentytwo">Recibiendo información</label> <input id="twentytwo" type="checkbox"><div class="index_list"> Cuando usted tiene una <tt>network_type_data</tt> tipo evento, que significa que su red ha recibido datos, el mapa creado tendrá las siguientes claves: <br><br><ul><li> <b>&quot;buffer&quot;:</b> esta es la única &quot;identificación del buffer&quot; que genera el evento. Un búfer de tipo &quot;crecer&quot;, byte alineado a 1, se crea para mantener el id. Debe almacenarse en una variable y usarse para todas las demás llamadas de función al búfer <i><b>en este caso</b></i>. Al igual que el <tt>async_load</tt> mapa, el búfer creado se elimina automáticamente de la memoria al final de este evento. Para obtener más información sobre los búferes, consulte <a href=
"../../../3_scripting/4_gml_reference/buffers/index.html">Referencia - Buffers</a> </li><li style="list-style: none"><br></li><li> <b>&quot;tamaño&quot;:</b> este es el tamaño (en bytes) de los datos del búfer que se están recibiendo. </li></ul><div class="note"> <b>NOTA:</b> El búfer creado <b>solo</b> es <b>válido en estos eventos</b> y se liberará cuando finalice el evento. </div></div></blockquote></div><br><a name="async_push" id="async_push"></a> <label class="collapse"
for="ten">Notificación de inserción</label> <input id="ten" type=
"checkbox"><div class="index_list"> El evento de notificación de inserción es uno que se desencadena por la devolución de llamada de <b>las notificaciones push</b> en el sistema operativo del dispositivo, ya sea desde una fuente local que usa la función <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/push_local_notification.html"><tt>push_local_notification</tt></a>, o desde una fuente remota (es decir: su servidor). Genera un <tt>ds_map</tt> es exclusivo de este evento y se almacena en la variable especial <b>async_load</b> (consulte las funciones individuales que desencadenan eventos asíncronos para ejemplos de código que explican el uso de este evento con más detalle). Esta <tt>ds_map</tt> tiene las siguientes claves: <br><br><ul><li> <b>&quot;tipo&quot;: el</b> valor puede ser &quot;local&quot; para una notificación local del dispositivo, &quot;remoto&quot; para una notificación remota, o &quot;registro&quot; para el registro remoto de notificaciones. </li><li> <b>&quot;estado&quot;: el</b> valor será &quot;1&quot; para el éxito o &quot;0&quot; para un error. </li></ul> Puede haber entradas clave adicionales basadas en el &quot;tipo&quot; devuelto y el valor &quot;estado&quot;. Para &quot;estado&quot;, si se ha devuelto un error (&quot;0&quot;), entonces también tendrá la siguiente clave: <br><br><ul><li> <b>&quot;error&quot;:</b> contiene detalles del error recibido. </li></ul> Si el valor de &quot;estado&quot; es 1 (es decir, no hay errores), entonces el <tt>ds_map</tt> contendrá los siguientes valores adicionales, según el valor de la tecla &quot;tipo&quot;: <br><br><ul><li> <b>&quot;reg_id&quot;:</b> si el &quot;tipo&quot; recibido fue &quot;registrarse&quot;, esta clave contendrá la identificación de registro del dispositivo para las notificaciones remotas. </li><li> <b>&quot;datos&quot;:</b> si el &quot;tipo&quot; recibido fue &quot;local&quot; o &quot;remoto&quot;, esta tecla contendrá la carga útil de cadena que definió cuando llamó a la función de notificación. </li></ul> Para comprender esto mejor, hemos creado un pequeño fragmento de ejemplo a continuación para que pueda ver. En este ejemplo, enviaremos una notificación de inserción local utilizando el siguiente código: <br><br><p class="code">var fireTime =
date_inc_day(date_current_datetime(), 1);<br>
var data = "daily_reward";<br>
push_local_notification(fireTime, "Ahoy!", "Catch The Haggis Has A
Present", data);<br><span class="notranslate"></span></p><br> Esto configurará un temporizador para &quot;enviar&quot; una notificación al dispositivo cuando haya pasado un día. Cuando el día se acabe, si tu juego está en segundo plano o no se está ejecutando, se mostrará una notificación al usuario con el título y el mensaje (en iOS, se muestra el nombre del juego y se ignora el título), y luego se llamará a un evento de notificación push asíncrono. Tenga en cuenta que si el juego está en primer plano cuando llega la hora de la notificación, <i>no</i> se mostrará, pero el evento asíncrono <b>se activará</b>. En el evento en sí, manejaría la devolución de llamada algo como esto: <br><br><p class="code">var type = ds_map_find_value(async_load,
"type");<br>
var status = ds_map_find_value(async_load, "status");<br>
if status == 0<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;//error of some kind<br>
&nbsp;&nbsp;&nbsp;var error = ds_map_find_value(async_load,
"error");<br>
&nbsp;&nbsp;&nbsp;show_debug_message("error=" + string(error));<br>
&nbsp;&nbsp;&nbsp;}<br>
else<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;if type == "register"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;global.reg_id =
ds_map_find_value(async_load, "reg_id");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var data =
ds_map_find_value(async_load, "data");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if data ==
"daily_reward"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;global.Gold
+= 1000;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p></div><br><a name="async_saveload" id="async_saveload"></a> <label class=
"collapse" for="eleven">Guardar carga</label> <input id="eleven"
type="checkbox"><div class="index_list"> Este evento se desencadenará por ciertas funciones relacionadas con la carga y guardado de búferes en los archivos, así como al cargar o descargar audio de la memoria. El evento en sí contendrá el construido en <tt>async_load</tt> Mapa de DS que se completará con las claves requeridas para la función específica. Estos se enumeran en las secciones a continuación. <blockquote><a name="async_saveload_buffers" id=
"async_saveload_buffers"></a> <label class="collapse" for=
"twentynine">Buffers</label> <input id="twentynine" type=
"checkbox"><div class="index_list"> Cuando usas las funciones <a href=
"../../../3_scripting/4_gml_reference/buffers/buffer_save_async.html"><tt>buffer_save_async()</tt></a> o <a href=
"../../../3_scripting/4_gml_reference/buffers/buffer_load_async.html"><tt>buffer_load_async()</tt></a> un evento asincrónico se activará cuando se haya completado la transferencia de datos. Este evento poblará el <tt>async_load</tt> mapa con los siguientes pares clave / valor <br><br><ul><li> <b>&quot;id&quot;:</b> la identificación de la función asíncrona devuelta por la función utilizada. </li><li> <b>&quot;estado&quot;:</b> volverá <tt>true</tt> si los datos se guardaron / cargaron correctamente, y <tt>false</tt> de otra manera. </li></ul> Esto le permite sondear el progreso de guardar / cargar y mostrar un mensaje o cambiar de habitación, etc.... cuando el proceso esté completo. </div><br><a name="async_saveload_audio" id="async_saveload_audio"></a> <label class="collapse" for="thirty">Grupos de audio</label> <input id="thirty" type="checkbox"><div class="index_list"> Al trabajar con <a href=
"../../../3_scripting/4_gml_reference/audio/audio%20groups.html">grupos de audio</a>, puede cargarlos y descargarlos de la memoria usando las funciones <a href=
"../../../3_scripting/4_gml_reference/audio/audio_group_load.html"><tt>
audio_group_load()</tt></a> y <a href=
"../../../3_scripting/4_gml_reference/audio/audio_group_unload.html"><tt>audio_group_unload()</tt></a>. Al usar la función de carga, activará este evento cuando el conjunto completo de archivos de audio configurados para el grupo se haya cargado en la memoria y completará el mapa con los siguientes pares clave / valor: <br><br><ul><li> <b>&quot;tipo&quot;:</b> esto nos dice el tipo de evento que se llama y será &quot; <tt>audiogroup_load</tt> &quot;para cargar audio. </li><li> <b>&quot;group_id&quot;:</b> devolverá la ID del grupo de audio que se ha cargado (como se define en el <a href=
"c:/source/yoyostudio/documentation/english/2_interface/3_settings/audio.html">Editor de grupos de audio</a> ). </li></ul> Cuando todo el audio se ha cargado para un grupo, este evento se activará y luego se puede usar para cambiar habitaciones, reproducir una pista de música, etc. </div></blockquote></div><br><a name="async_social" id="async_social"></a> <label class=
"collapse" for="eight">Social</label> <input id="eight" type=
"checkbox"><div class="index_list"> Este evento solo puede ser activado por las diversas <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/index.html">funciones sociales</a> específicas y devolverá un <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> almacenado en la variable <tt>async_load</tt>, que contiene diferentes pares clave / valor en función de la devolución de llamada de la función que ha desencadenado el evento. <br><br> El ds_map contendrá un número de claves, la más importante de las cuales es la clave &quot; <i>id</i> &quot;. Esto devolverá una <b>constante</b> que luego se puede verificar en el código para determinar cuál de las muchas devoluciones de llamada ha recibido el evento. Una vez que haya analizado esta clave y comparado el valor devuelto con las constantes disponibles, puede continuar extrayendo el resto de la información del mapa. <blockquote><a name="async_social_leaderboards" id=
"async_social_leaderboards"></a> <label class="collapse" for=
"twentyseven">Marcadores y Logros</label> <input id=
"twentyseven" type="checkbox"><div class="index_list"> Las páginas de funciones en <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/achievements%20and%20leaderboards/index.html">Social Gaming - Achievements y Leaderboards</a> en la sección de referencia detallan las funciones y las devoluciones de llamada, así como las constantes utilizadas para desencadenar este evento, pero también hay ciertas circunstancias en las que se activará sin una llamada de función del juego que Esta corriendo: <br><br><ul><li> cuando tu juego se lanza desde el tablero del sistema operativo </li><li> cuando completas un desafío </li><li> cuando otro jugador completa un desafío </li><li> cuando el juego se inicia desde el tablero del sistema operativo seleccionando un desafío </li></ul><p> Cualquiera de las devoluciones de llamada anteriores activará el <b>evento social</b> y un <tt>async_load</tt> el mapa se generará con los siguientes detalles (tenga en cuenta que hay un valor de clave &quot;id&quot; diferente para definir cada una de las diferentes razones por las que se llamó al evento, pero todos los demás contenidos del mapa son los mismos): <br><br></p><ul><li> &quot; <b>id</b> &quot;: el valor de esta clave dependerá del tipo de devolución de llamada que active el evento. puede ser una de estas constantes: <br><br><ul><li> <b><tt>achievement_challenge_received</tt></b> - Un desafío ha sido recibido <br></li><li> <b><tt>achievement_challenge_completed</tt></b> - Un desafío ha sido completado. <br></li><li> <b><tt>achievement_challenge_completed_by_remote</tt></b> - Un desafío ha sido completado por el otro jugador. <br></li><li> <b><tt>achievement_challenge_launched</tt></b> - El juego se lanzó desde el tablero del sistema operativo con el desafío dado. <br></li></ul></li><li> &quot; <b>playerid</b> &quot;: la identificación del jugador para el desafío. <br><br></li><li> &quot; <b>issuerid</b> &quot;: la identificación de la persona que emitió el desafío. <br><br></li><li> &quot; <b>estado</b> &quot;: el estado del desafío, que tendrá un valor de 0 - 3 (como una cadena) para <i>inválido</i>, <i>pendiente</i>, <i>completado</i> o <i>rechazado</i>. <br><br></li><li> &quot; <b>mensaje</b> &quot; - El mensaje de texto para desafío. <br><br></li><li> &quot; <b>issueddate</b> &quot; - La fecha de emisión del desafío <br><br></li><li> &quot; <b>completeddate</b> &quot;: la fecha de finalización del desafío. <br><br></li><li> &quot; <b>tipo</b> &quot; - El tipo de desafío dado. Puede ser una de dos constantes: <br><br><ul><li> <b><tt>achievement_type_score_challenge</tt></b> - Un desafío basado en el valor del puntaje. <br></li><li> <b><tt>achievement_type_achievement_challenge</tt></b> - Un desafío basado en un logro. <br></li></ul></li><li> &quot; <b>identificador</b> &quot;: la cadena de identificación para el desafío. <br><br></li><li> &quot; <b>puntaje</b> &quot; - El puntaje empatado con el desafío. </li></ul> A continuación, puede encontrar un pequeño fragmento de código como ejemplo de uso: <br><br><p class="code">var ident = ds_map_find_value(async_load, "id"
);<br>
if ident == achievement_challenge_completed;<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;player_id = ds_map_find_value(async_load,
"playerid");<br>
&nbsp;&nbsp;&nbsp;issuer_id = ds_map_find_value(async_load,
"issuerid");<br>
&nbsp;&nbsp;&nbsp;state = ds_map_find_value(async_load,
"state");<br>
&nbsp;&nbsp;&nbsp;date_completed = ds_map_find_value(async_load,
"completeddate");<br>
&nbsp;&nbsp;&nbsp;date_issued = ds_map_find_value(async_load,
"issueddate");<br>
&nbsp;&nbsp;&nbsp;ach_type = ds_map_find_value(async_load,
"type");<br>
&nbsp;&nbsp;&nbsp;ach_ident = ds_map_find_value(async_load,
"identifier");<br>
&nbsp;&nbsp;&nbsp;ach_score = ds_map_find_value(async_load,
"score");<br>
&nbsp;&nbsp;&nbsp;}<span class="notranslate"></span></p></div><br><a name="async_social_facebook" id="async_social_facebook"></a> <label class="collapse" for="twentyeight">Facebook</label> <input id="twentyeight" type="checkbox"><div class="index_list"> Algunas de las <a href=
"../../../3_scripting/4_gml_reference/asynchronous%20functions/facebook/index.html">funciones de Facebook</a> desencadenarán un evento asincrónico social y crearán un <tt>ds_map</tt> con alguna información específica. La información devuelta dependerá del &quot;tipo&quot; de evento que se haya llamado. Puede verificar esto leyendo la clave &quot;tipo&quot; del ds_map, que será la siguiente cadena para un evento de Facebook: <br><br><ul><li> &quot; <b>facebook_permission_request</b> &quot; </li></ul><p> Cuando se desencadena el evento y es de este tipo, también habrá claves adicionales que se pueden verificar: </p><ul><li> <b>&quot;RequestID&quot;</b> - El valor de ID de solicitud devuelto por el <tt>facebook_request_xxx_permission()</tt> función que desencadenó el evento <br><br></li><li> &quot; <b>resultado</b> &quot;: esta será una de las siguientes cadenas: <br><br><ul><li> &quot; <b>concedido</b> &quot;: los permisos fueron aceptados por el usuario </li><li> &quot; <b>denegado</b> &quot;: uno o más permisos no fueron aceptados por el usuario </li><li> &quot; <b>error</b> &quot; - se produjo un error </li></ul></li><li> <b>&quot;error</b> &quot; - Esto contendrá una descripción del error, pero <i>solo</i> está presente cuando &quot; <b>result</b> &quot; = &quot; <b>error</b> &quot;. </li></ul></div></blockquote></div><br><a name="async_steam" id="async_steam"></a> <label class="collapse"
for="seven"><span class="notranslate">Steam</span></label> <input id="seven" type="checkbox"> <div class="index_list"> Este evento solo puede ser activado por las funciones de <a href=
"../../../3_scripting/4_gml_reference/steam%20api/index.html"><span class="notranslate">Steam</span> API</a> y devolverá un <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> almacenado en la variable <tt>async_load</tt>, que contiene diferentes pares de clave / valor dependiendo de la devolución de llamada de la función que ha desencadenado el evento. El mapa siempre contendrá la clave &quot; <b>event_type</b> &quot; que luego se puede analizar para encontrar el tipo de función que activó el evento y cambiar el código requerido para que coincida. <br><br> Cuando se llama a cualquier función que desencadena este evento, generará un valor único de identificación asíncrona que se debe almacenar en una variable y comprobarse, como <tt>async_load</tt> El mapa siempre contendrá una clave de identificación que luego puede analizar y asegurarse de que está respondiendo al evento correcto. De hecho, el mapa <i>siempre</i> mantendrá las siguientes teclas, independientemente de la función de <span class="notranslate">Steam</span> utilizada para generar la respuesta asincrónica: <br><br><ul><li> &quot; <b>id</b> &quot;: la identificación asíncrona devuelta por la función que activó el evento </li><li style="list-style: none"><br></li><li> &quot; <b>resultado</b> &quot; - El resultado de la operación (un valor real). Esta será la constante GML <tt>ugc_result_success</tt> o algún otro número real. Por lo tanto, debe verificar esta constante para asegurarse de que la llamada fue exitosa, y si no, algo no funcionó correctamente. El resto de los posibles valores devueltos se muestran como resultado del valor &quot;EResult&quot; de <span class="notranslate">Steam</span> y debería ver <tt>steamclientpublic.h</tt> en los encabezados del SDK para los 89 valores posibles. </li><li style="list-style: none"><br></li><li> &quot; <b>event_type</b> &quot; - Una cadena que denota el tipo de evento (ver detalles a continuación) </li></ul><blockquote><a name="async_steam_uploading" id=
"async_steam_uploading"></a> <label class="collapse" for=
"twentythree">Cargando datos</label> <input id="twentythree" type=
"checkbox"><div class="index_list"> Al usar las funciones <span class="notranslate">Steam</span> para cargar una tabla de clasificación (ya sea <a href=
"../../../3_scripting/4_gml_reference/steam%20api/steam_upload_score.html"><tt>steam_upload_score()</tt></a> o <a href=
"../../../3_scripting/4_gml_reference/steam%20api/steam_upload_score_buffer.html"><tt>steam_upload_score_buffer()</tt></a> ) El retorno <tt>ds_map</tt> tendrá los siguientes pares clave / valor: <br><br><ul><li> &quot; <b>event_type</b> &quot; - Esta tecla mantendrá el valor &quot; <b>leaderboard_upload</b> &quot; </li><li style="list-style: none"><br></li><li> &quot; <b>post_id</b> &quot;: esta clave debe coincidir con el valor de ID devuelto por la función de carga de carga </li><li style="list-style: none"><br></li><li> &quot; <b>lb_name</b> &quot; - Esta tecla contiene el nombre de la tabla de clasificación que se envió a </li><li style="list-style: none"><br></li><li> &quot; <b>éxito</b> &quot;: será 1 si la publicación fue <b>exitosa</b>, 0 falló </li><li style="list-style: none"><br></li><li> &quot; <b>actualizado</b> &quot;: será 1 si el puntaje de la tabla de clasificación realmente se actualizó (es decir: la nueva puntuación fue mejor) o 0 de lo contrario </li><li style="list-style: none"><br></li><li> &quot; <b>puntaje</b> &quot; - Esta tecla contiene el puntaje que fue publicado </li></ul> Puede ver ejemplos de esto en las páginas para las funciones de carga de puntajes. </div><br><a name="async_steam_downloading" id="async_steam_downloading"></a> <label class="collapse" for="twentyfour">Descargar tablas de clasificación</label> <input id="twentyfour" type="checkbox"><div class="index_list"> Al usar las funciones de <span class="notranslate">Steam</span> para descargar una tabla de clasificación ( <a href=
"../../../3_scripting/4_gml_reference/steam%20api/steam_download_scores.html"><tt>steam_download_scores()</tt></a>, <a href=
"../../../3_scripting/4_gml_reference/steam%20api/steam_download_scores_around_user.html"><tt>steam_download_scores_around_user()</tt></a> o <a href=
"../../../3_scripting/4_gml_reference/steam%20api/steam_download_friends_scores.html"><tt>steam_download_friends_scores()</tt></a> ) El retorno <tt>ds_map</tt> tendrá los siguientes pares clave / valor: <br><br><ul><li> &quot; <b>event_type</b> &quot; - Esta tecla mantendrá el valor &quot; <b>leaderboard_download</b> &quot; </li><li style="list-style: none"><br></li><li> &quot; <b>id</b> &quot; - Esta clave debe coincidir con el valor ID devuelto por la función de llamada de descarga </li><li style="list-style: none"><br></li><li> &quot; <b>estado</b> &quot;: el estado de la devolución de llamada, donde -1 equivale a una falla o que no se devolvieron resultados, y 0 es igual a un éxito. </li><li> &quot; <b>lb_name</b> &quot; - Esta tecla contiene el nombre de la tabla de clasificación que se envió a </li><li style="list-style: none"><br></li><li> &quot; <b>numEntries</b> &quot;: la cantidad de &quot;filas&quot; de datos de la tabla de clasificación que se devuelve. </li><li style="list-style: none"><br></li><li> &quot; <b>entradas</b> &quot;: una cadena de objetos JSON que contiene otro ds_map, que contendrá la clave &quot;por defecto&quot; (lo que significa que no hay resultados dentro) o las &quot;entradas&quot; clave, de las que luego puede obtener el valor. este valor devuelto para &quot;entradas&quot; será un <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20lists/index.html"><tt>ds_list</tt></a> que contiene cada uno de los rangos de la tabla de clasificación, donde cada entrada de la lista hará referencia a otra <tt>ds_map</tt> que contendrá las claves &quot;nombre&quot;, &quot;puntaje&quot; y &quot;rango&quot;, y también puede contener una clave de &quot;datos&quot; dependiendo de la función utilizada para cargar. </li></ul> Mostraremos un ejemplo de cómo funciona la descarga de datos de puntuación solicitando el ranking de los diez primeros para la clasificación dada y analizando sus resultados en el <b>evento <span class="notranslate">Steam</span> Async</b> (para cargar ejemplos, consulte las páginas de funciones apropiadas). Para empezar, necesitamos solicitar los puntajes con el siguiente código: <br><br><p class="code">score_get = steam_download_scores("Game Scores", 1,
10);<br><span class="notranslate"></span></p><br> Esto enviará una solicitud al servidor de <span class="notranslate">Steam</span> para los puntajes de la tabla de clasificación &quot;Puntuaciones del juego&quot;, almacenando la <b>identificación asincrónica</b> de la solicitud en la variable &quot;score_get&quot;. Esto se manejará en el <b>evento <span class="notranslate">Steam</span> Async</b> de la siguiente manera: <br><br><p class="code">var async_id = ds_map_find_value(async_load,
"id");<br>
if async_id == score_get<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;var entries = ds_map_find_value(async_load,
"entries");<br>
&nbsp;&nbsp;&nbsp;var map = json_decode(entries);<br>
&nbsp;&nbsp;&nbsp;if ds_map_exists(map, "default")<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ds_map_destroy(map);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var list =
ds_map_find_value(map, "entries");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var len =
ds_list_size(list);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var entry;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(var i = 0; i &lt; len;
i++;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entry =
ds_list_find_value(list, i );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;steam_name[i]
= ds_map_find_value(entry, "name");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;steam_score[i]
= ds_map_find_value(entry, "score");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;steam_rank[i]
= ds_map_find_value(entry, "rank");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
(ds_map_exists(entry, "data"))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var
data = ds_map_find_value(entry, "data");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var
buffId = buffer_base64_decode(data);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var
message = buffer_read(buffId, buffer_string);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;show_debug_message(
" -- attached message: " + string(message));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer_delete(buffId);<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ds_map_destroy(entry);<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ds_list_destroy(list)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;ds_map_destroy(map)<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> Lo que hacemos aquí es verificar primero la clave &quot;id&quot; del especial <tt>async_load</tt> mapa. Si este valor es el mismo que el valor de la función de devolución de llamada original (almacenada en la variable &quot;score_get&quot;), seguiremos procesando los datos. Lo primero que hacemos es analizar el <tt>async_load</tt> ds_map para las &quot;entradas&quot; clave que contendrán un objeto JSON que contiene los datos de la tabla de clasificación. Este objeto JSON se decodifica (ver <a href=
"../../../3_scripting/4_gml_reference/file%20handling/json_decode.html"><tt>json_decode</tt></a> ) como otro ds_map, y este nuevo ID de mapa se almacena en la variable &quot;mapa&quot;. <br><br> Este mapa se marca con la clave &quot;predeterminada&quot; y, si se encuentra, se destruye el mapa y se cierra el evento. Si no se encuentra una clave &quot;predeterminada&quot;, el código analizará el mapa para extraer la información necesaria sobre la tabla de clasificación, primero extrayendo una ds_list de la tecla &quot;entradas&quot; del ds_map, y luego recorriendo cada entrada de la lista para obtener <i>otro</i> ds_map con el nombre, puntaje y rango de cada entrada. Estos valores se almacenan en matrices y luego verificamos si hay una clave adicional de &quot;datos&quot;. Si lo hay (es decir: el puntaje se cargó con un paquete de datos adicional), también lo analizamos y lo enviamos a la consola del compilador para su depuración, antes de destruir el búfer y luego continuar para destruir el mapa. Tenga en cuenta que si se incluye la clave &quot;datos&quot;, debe decodificarse utilizando el <a href=
"../../../3_scripting/4_gml_reference/buffers/buffer_base64_decode.html"><tt>buffer_base64_decode()</tt></a> antes de que pueda leerse correctamente. <br><br> Una vez que el ciclo ha finalizado, la lista de entradas se destruye al igual que el mapa del que se tomó. No hay necesidad de destruir el <tt>async_load</tt> ds_map, ya que esto es manejado por <i><span class="notranslate">GameMaker Studio 2</span></i>. </div><br><a name="async_steam_downloadingugc" id=
"async_steam_downloadingugc"></a> <label class="collapse" for=
"twentyfive">Descargar UGC (contenido generado por el usuario)</label> <input id="twentyfive" type="checkbox"><div class="index_list"> Al usar las funciones de <span class="notranslate">Steam</span> para descargar <a href=
"../../../3_scripting/4_gml_reference/steam%20api/user%20generated%20content/index.html">contenido generado</a> por el <a href=
"../../../3_scripting/4_gml_reference/steam%20api/user%20generated%20content/index.html">usuario (UGC)</a>, varias de ellas desencadenarán este evento. Sin embargo, cada función generará un <tt>async_load</tt> ds_map con diferentes pares de clave / valor (aunque siempre contendrán las claves generales &quot; <b>id</b> &quot;, &quot; <b>result</b> &quot; y &quot; <b>event_type</b> &quot;), por lo tanto, consulte la página específica de la función que se utiliza para obtener detalles y ejemplos. </div><br><a name="async_steam_ugc_events" id="async_steam_ugc_events"></a> <label class="collapse" for="twentysix">Eventos únicos de UGC</label> <input id="twentysix" type="checkbox"><div class="index_list"> El evento <span class="notranslate">Steam</span> Async también se puede activar cuando un usuario se suscribe a un elemento fuera del juego; por ejemplo, se aleja de la pestaña de un navegador y se suscribe a un nuevo elemento, luego regresa al juego. En estos casos, <tt>async_load</tt> el mapa <b>solo</b> contendrá los siguientes detalles (y ninguno de los valores predeterminados enumerados en la parte superior de esta página): <br><br><ul><li> &quot; <b>event_type</b> &quot; - Esta clave mantendrá el valor &quot; <b>ugc_item_installed</b> &quot; </li><li style="list-style: none"><br></li><li> &quot; <b>published_file_id</b> &quot;: el ID del elemento UGC recién instalado (puede usar la función <a href=
"../../../3_scripting/4_gml_reference/steam%20api/user%20generated%20content/steam_ugc_get_item_install_info.html"><tt>steam_ugc_get_item_install_info()</tt></a> para obtener la ruta al elemento instalado) </li><li style="list-style: none"><br></li></ul> El evento <span class="notranslate">Steam</span> Async también se puede activar cuando se suscribe un elemento del taller, ya sea desde dentro de la aplicación o externamente desde un navegador de taller, y en estos casos el <tt>async_load</tt> el mapa contendrá los siguientes pares clave / valor: <br><br><ul><li> &quot; <b>event_type</b> &quot; - Esta tecla mantendrá el valor &quot; <b>ugc_item_subscribed&quot;</b> &quot; </li><li style="list-style: none"><br></li><li> &quot; <b>published_file_id</b> &quot;: esta clave tiene el ID de archivo publicado del elemento recién suscrito </li><li style="list-style: none"><br></li></ul> El evento se activará en caso de que algún elemento no se suscriba también, con el mapa DS conteniendo lo siguiente: <br><br><ul><li> &quot; <b>event_type</b> &quot; - Esta tecla mantendrá el valor &quot; <b>ugc_item_unsubscribed&quot;</b> &quot; </li><li style="list-style: none"><br></li><li> &quot; <b>published_file_id</b> &quot;: esta clave tiene el ID de archivo publicado del elemento no suscrito </li><li style="list-style: none"><br></li></ul></div></blockquote></div><br><a name="async_system" id="async_system"></a> <label class=
"collapse" for="fourteen">Sistema</label> <input id="fourteen" type=
"checkbox"><div class="index_list"><p> Este evento solo puede ser desencadenado por un evento de nivel de sistema (como la detección de un gamepad o el inicio de sesión automático en XBox Live) y devolverá un <a href=
"../../../3_scripting/4_gml_reference/data_structures/ds%20maps/index.html"><tt>ds_map</tt></a> almacenado en la variable <tt>async_load</tt>, que contiene diferentes pares de clave / valor según el evento de nivel de sistema que activó la devolución de llamada. </p><blockquote><a name="async_system_gamepads" id=
"async_system_gamepads"></a> <label class="collapse" for=
"thirtyone">Juego de almohadillas</label> <input id="thirtyone" type=
"checkbox"><div class="index_list"><p> Cuando este evento se desencadena para que un gamepad se conecte o desconecte, devolverá uno de los siguientes pares clave / valor en el <tt>async_load</tt> mapa: <br><br></p><ul><li> &quot; <b>event_type</b> &quot;: el tipo de evento del sistema recibido, que será una de las siguientes cadenas: <br><br><ul><li> &quot; <b>gamepad descubierto</b> &quot;: sucede cuando el sistema informa que se ha conectado un nuevo gamepad </li><li> &quot; <b>gamepad perdido</b> &quot;: sucede cuando el sistema perdió la conexión a un gamepad </li></ul></li><li> &quot; <b>pad_index</b> &quot; - el índice de la plataforma que se ha agregado o eliminado </li></ul><p> Este evento ahora te permite mover toda tu lógica de control del gamepad desde el Evento Paso o un evento de Alarma al Evento del Sistema y solo ejecutarlo cuando realmente se requiera. </p></div><br><a name="async_system_xboxlive" id="async_system_xboxlive"></a> <label class="collapse" for="thirtytwo">XBox Live</label> <input id="thirtytwo" type="checkbox"><div class="index_list"><p> El evento del sistema asíncrono puede activarse al dirigirse al <b><span class="notranslate">XBox One</span></b> utilizando la exportación <b>UWP</b> y al marcar la opción <b>Habilitar XBox Live</b> en las <a href=
"../../../2_interface/3_settings/game_options/options_windowsuwp.html">Opciones del juego UWP</a>. Cuando inicie el proyecto UMB de <i><span class="notranslate">GameMaker Studio 2</span></i> que tiene Xbox Live habilitado, el proyecto intentará iniciar sesión silenciosamente en Xbox Live. Los resultados de este intento de inicio de sesión se devolverán como uno de los siguientes pares de clave / valor en el <tt>async_load</tt> mapa: </p><ul><li> &quot; <b>event_type</b> &quot;: el tipo de evento del sistema recibido, que será una de las siguientes cadenas: <br><br><ul><li> &quot; <b>usuario</b> registrado&quot;: el inicio de sesión silencioso del usuario se ha completado con éxito </li><li> &quot; <b>inicio de sesión de usuario fallido</b> &quot;: el inicio de sesión silencioso del usuario ha fallado (cuando esto sucede puede usar la función <a href=
"../../../3_scripting/4_gml_reference/xbox_live/xboxlive_show_account_picker.html"><tt>xboxlive_show_account_picker()</tt></a> para que el usuario elija una cuenta para iniciar sesión con) </li><li> &quot; <b>usuario desconectado</b> &quot;: el usuario se ha desconectado </li></ul></li></ul><p> Para obtener más información sobre las funciones específicas disponibles para XBox Live, consulte <a href=
"../../../3_scripting/4_gml_reference/xbox_live/index.html">aquí</a>. </p></div></blockquote></div></blockquote><p><br></p></div><div class="footer"><div class="buttons"><div class="clear"><div style="float:left"> Atrás: <a href="../objects.html">El Editor de Objetos</a> </div><div style="float:right"> Siguiente: <a href="draw_events.html">Dibujar eventos</a> </div></div></div><h5> © Copyright <span class="notranslate">YoYo Games Ltd.</span> 2017 Todos los derechos reservados </h5>
<script type="text/javascript">
   (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');   ga('create', 'UA-2711665-14', 'auto');   ga('send', 'pageview'); 
</script>
</div>

<script type="text/JavaScript">
var fe = FindFrame("toc", top);
if ((fe != null) && (chmtop.c2wtopf.jstree != null)) {
  if (chmtop.c2wtopf.FITEMS[chmtop.c2wtopf.pagenum] != chmtop.c2wtopf.pageid)
    chmtop.c2wtopf.jstree.OpenTreeNode("source/" + chmtop.c2wtopf.pageid);
}
</script>
</body>
</html>

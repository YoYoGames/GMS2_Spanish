<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="keywords" content="online documentation, web online help, web help, chm2web" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="generator" content="chm2web Pro 2.85 (unicode)" />
<title>Using Buffers</title>
<meta http-equiv="X-UA-Compatible" content="IE=9">

<link rel="stylesheet" href="../../../../files/helpindex.css" type=
"text/css">
<link rel="stylesheet" href="../../../../default.css" type=
"text/css">

<script type="text/JavaScript" src="../../../../files/supply.js"></script>
<script type="text/JavaScript">
chmtop.c2wtopf.pageid = "_build/1_overview/3_additional_information/using_buffers.html";
</script>

</head>
<body><script type="text/JavaScript"> 
if (window.name != "content") 
  document.write(" <table width=\"100%\" bgcolor=\"#e1e1e1\"cellspacing=\"2\" cellpadding=\"0\" style=\"border-collapse: collapse; font-family: sans-serif; font-size: 14px; color: #000000; text-decoration: none;  \"> <tr> <td align=\"center\" style=\"border-bottom: 2px solid gray\" > <br>&nbsp;Click <a href=\"../../../../index.html?page=source%2F_build%2F1_overview%2F3_additional_information%2Fusing_buffers.html\">here</a> to show toolbars of the Web Online Help System: <a href=\"../../../../index.html?page=source%2F_build%2F1_overview%2F3_additional_information%2Fusing_buffers.html\">show toolbars</a><br>&nbsp;</td></tr></table><br> "); 
</script>
<!-- !chm2web! --><script type="text/JavaScript">
 if( typeof(chmtop.helpStyle) != 'undefined' ) { var linkNodes = document.getElementsByTagName("link");  for( var i=0; i < linkNodes.length; ++i ) { var link = linkNodes[i];    if( link.href.endsWith("default.css")) {    var style = link.href.replace("default.css", chmtop.helpStyle); document.write('<link id="newstyleLink" rel="stylesheet" href=' + style + ' type="text/css">');    break; } } } 
</script><h2> Usando Buffers </h2><div class="body-scroll"><p><br></p><p> <i><span class="notranslate">GameMaker Studio 2</span></i> tiene una serie de funciones en GML para tratar con los <b>buffers</b>. La mayoría de la gente debería estar familiarizada con este término, ya que se usa todo el tiempo cuando se trata de computadoras y programación, pero conocer la palabra no significa que realmente sepas lo que significa. Así que esta página pretende explicar qué es un búfer y cómo usarlos en el contexto de la programación de <i><span class="notranslate">GameMaker Studio 2</span></i>, aunque la forma general en que funcionan es la misma sin importar el idioma o la tecnología, que es una de las razones por las que son muy importante. </p><blockquote><a name="buffers" id="buffers"></a> <label class=
"collapse" for="one">¿Qué es un buffer?</label> <input id="one"
type="checkbox"><div class="index_list"> Un búfer (en programación) es básicamente un espacio dentro de la memoria del sistema que se usa para almacenar pequeños <i>paquetes</i> de datos para casi cualquier cosa (por ejemplo, transferencia de datos, colisiones, datos de color, etc.). Como se almacena en la memoria del sistema, es muy rápido de acceder, y generalmente se usaría un búfer para almacenamiento a muy corto plazo, como recibir información de red antes de procesarla o almacenar un punto de control en su juego (esto se explica en el ejemplo dado más abajo en la página). <img class="center" src=
"images/buffer_memory.png" alt="Memoria tampón"> Los búferes se crean asignando un espacio en la memoria del sistema, calculado en <b>bytes</b>, que luego se reserva para su juego siempre que su juego esté en ejecución o hasta que elimine el búfer utilizando la función apropiada. Esto significa que incluso cuando su juego no está enfocado (por ejemplo, en un dispositivo móvil cuando toma una llamada, el juego se pondrá en segundo plano), el búfer seguirá existiendo; sin embargo, si el juego se cierra o se reinicia, buffer se perderá. <br><br><div class="note"> <b>NOTA: ¡</b> Reiniciar el juego no borrará o eliminará el búfer! Pero evitará que se habrá perdido cualquier nuevo acceso a la memoria intermedia creada anteriormente como el <b>mango</b> Identificación, causando una pérdida de memoria, que se colgará su juego con el tiempo. Por lo tanto, cuando reinicie un juego, recuerde eliminar primero el búfer. </div></div><br><a name="buffer_types" id="buffer_types"></a> <label class=
"collapse" for="two">Tipos de buffer</label> <input id="two" type=
"checkbox"><div class="index_list"> <i><span class="notranslate">GameMaker Studio 2</span></i> permite la creación de cuatro tipos de buffer diferentes. La razón de esto es que los almacenamientos intermedios están diseñados para ser un medio de almacenamiento temporal altamente optimizado y, como tal, debe crear un almacenamiento intermedio que sea apropiado para el tipo de datos que desea almacenar; de lo contrario, podría obtener errores o causar un <i>cuello de botella</i> en tu código Antes de explicar esto más a fondo, veamos los cuatro tipos de búfer disponibles (definidos como <b>constantes</b> en GML): <br><br><div class="compat"><table><tr><th> Constante </th><th> descripción </th></tr><tr><td> <span class="notranslate">buffer_fixed</span> </td> <td><br> Un búfer de un tamaño fijo en bytes. El tamaño se establece cuando se crea el búfer y no se puede cambiar de nuevo. <br><br></td></tr><tr class="alt"><td> <span class="notranslate">buffer_grow</span> </td> <td><br> Un búfer que <i>crecerá</i> dinámicamente a medida que se agreguen datos. Usted lo crea con un tamaño inicial (que debe ser una aproximación del tamaño de los datos que se espera almacenar), y luego se expandirá para aceptar más datos que desborden este tamaño inicial. <br><br></td></tr><tr><td> <span class="notranslate">buffer_wrap</span> </td> <td><br> Un búfer donde se <i>envolverán</i> los datos. Cuando los datos que se agregan alcanzan el límite del tamaño del búfer, la sobrescritura se volverá a colocar al inicio del búfer, y la escritura continuará desde ese punto. <br><br></td></tr><tr class="alt"><td> <span class="notranslate">buffer_fast</span> </td> <td><br> Este es un búfer especial &quot;reducido&quot; que es extremadamente rápido para leer / escribir. Sin embargo, solo se puede usar con <tt>buffer_u8</tt> tipos de datos, y deben estar alineados a 1 byte. (La información sobre <b>los tipos de datos</b> y la <b>alineación de bytes</b> se puede encontrar más abajo en esta página). <br><br></td></tr></table></div><br><br> Esos son los tipos de búfer disponibles para usted cuando usa <i><span class="notranslate">GameMaker</span> Studio 2</i>, y el que elija dependerá en gran medida del uso que desee darle. Por ejemplo, un buffer de <b>crecimiento</b> se usaría para almacenar una &quot;instantánea&quot; de datos para crear un juego de salvar ya que no se conoce la cantidad real de datos que se colocarán en él, o se usaría un búfer <b>rápido</b> cuando sepa que los valores con los que está trabajando están todos entre 0 y 255 o -128 y 127, por ejemplo al procesar datos RGB de una imagen. <img class="center" src="images/buffer_types.png" alt="Tipos de buffer"> Al crear un búfer, siempre debe intentar crearlo en un tamaño que sea apropiado para el tipo, con la regla general de que debe crearse para acomodar el tamaño máximo de datos que debe almacenar y, en caso de duda, use un buffer de <b>crecimiento</b> para evitar errores de sobrescritura. <br><br> El código real para crear un búfer se vería así: <br><br><p class="code">player_buffer = buffer_create(16384, buffer_fixed,
2);<span class="notranslate"></span></p><br> Eso crearía un búfer fijo de 16384 bytes y un <b>byte alineado</b> a 2, con la función que devuelve un valor único de <b>identificación</b> que se almacena en una variable para referencia posterior de este búfer. Ahora tenemos el concepto básico de un búfer explicado que debe aprender sobre <b>los tipos de datos</b> y la <b>alineación de bytes</b> antes mencionados. </div><br><a name="buffer_data_types" id="buffer_data_types"></a> <label class="collapse" for="three">Tipos de datos de buffer</label> <input id="three" type="checkbox"><div class="index_list"> Cuando lee y escribe datos en un búfer, lo hace en &#39;&#39; fragmentos &#39;&#39; de datos definidos por su &#39;&#39; &#39;tipo de datos&#39; &#39;&#39;. El &#39;&#39; &#39;tipo de datos&#39; &#39;&#39; establece el número de bytes asignados dentro del búfer para el valor que se está escribiendo, y es esencial que lo haga de otra forma, de lo contrario obtendrá resultados muy extraños (o incluso errores) para su código. <br><br> Los búferes se escriben (y leen) de forma <i>secuencial</i>, ya que una parte de los datos se escribe después de otra, y cada elemento de datos es de un tipo establecido. Esto significa que lo ideal es que esté al tanto de los datos que está escribiendo en el búfer en todo momento. Estos <b>tipos de datos</b> se definen en GML mediante las siguientes <i>constantes</i>: <div class="compat"><table><tr><th> Tipo de datos constante </th><th> Bytes </th><th> Descripción </th></tr><tr><td> buffer_u8 </td><td> 1 </td><td><br> Un entero sin signo de 8 bits. Este es un valor positivo de 0 a 255. <br><br></td></tr><tr class="alt"><td> buffer_s8 </td><td> 1 </td><td><br> Un entero de 8 bits con signo. Este puede ser un valor positivo o negativo de -128 a 127 (0 se clasifica como positivo). <br><br></td></tr><tr><td> buffer_u16 </td><td> 2 </td><td><br> Un entero sin signo de 16 bits. Este es un valor positivo de 0 - 65,535. <br><br></td></tr><tr class="alt"><td> buffer_s16 </td><td> 2 </td><td><br> Un entero firmado de 16 bits. Este puede ser un valor positivo o negativo de -32,768 a 32,767 (0 se clasifica como positivo). <br><br></td></tr><tr><td> buffer_u32 </td><td> 4 </td><td><br> Un entero sin signo de 32 bits. Este es un valor positivo de 0 a 4.294.967.295. <br><br></td></tr><tr class="alt"><td> buffer_s32 </td><td> 4 </td><td><br> Un entero firmado de 32 bits. Este puede ser un valor positivo o negativo de -2,147,483,648 a 2,147,483,647 (0 se clasifica como positivo). <br><br></td></tr><tr><td> buffer_f16 </td><td> 2 </td><td><br> Un número de coma flotante de 16 bits. Esto puede ser un valor positivo o negativo dentro del rango de +/- 65504. <b>(¡Actualmente no es compatible!)</b> <br><br></td></tr><tr class="alt"><td> buffer_f32 </td><td> 4 </td><td><br> Un número de coma flotante de 32 bits. Este puede ser un valor positivo o negativo dentro del rango de +/- 16777216. <br><br></td></tr><tr><td> buffer_f64 </td><td> 8 </td><td><br> Un número de punto flotante de 64 bits. Este puede ser un valor positivo o negativo de - (2 <sup>52</sup> ) a 2 <sup>52</sup> - 1. <br><br></td></tr><tr class="alt"><td> buffer_bool </td><td> 1 </td><td><br> Un valor booleano. Solo puede ser 1 o 0 ( <tt>true</tt> o <tt>false</tt> ) <br><br></td></tr><tr><td> buffer_string </td><td> N / A </td><td><br> Esta es una cadena terminada en nulo UTF-8 (0x00). Básicamente, una secuencia de <span class="notranslate">GameMaker</span> se descarga en el búfer y se pone un 0 al final. <br><br></td></tr></table></div><br><br> Entonces, digamos que ha creado un búfer y desea escribir información en él, entonces usaría algo como el siguiente código: <br><br><p class="code">buffer_write(buff, buffer_bool, global.Sound);<br>
buffer_write(buff, buffer_bool, global.Music);<br>
buffer_write(buff, buffer_s16, obj_Player.x);<br>
buffer_write(buff, buffer_s16, obj_Player.y);<br>
buffer_write(buff, buffer_string, global.Player_Name);<br><span class="notranslate"></span></p><br> mirando el ejemplo anterior, puede ver que puede escribir diferentes tipos de datos en un búfer (solo está limitado a un tipo de datos específico cuando utiliza el tipo de búfer <b>rápido</b> ), y estos datos se agregarán al búfer de forma consecutiva (aunque su la posición real en el búfer dependerá de su <b>alineación de bytes</b>, que se explica a continuación). Esto es lo mismo para leer información del búfer, y en el caso del ejemplo anterior, leería del búfer en el mismo orden en que escribió los datos, buscando el mismo tipo de datos, por ejemplo: <br><br><p class="code">global.Sound = buffer_read(buff, buffer_bool);<br>
global.Music = buffer_read(buff, buffer_bool);<br>
obj_Player.x = buffer_read(buff, buffer_s16);<br>
obj_Player.y = buffer_read(buff, buffer_s16);<br>
global.Player_Name = buffer_read(buff, buffer_string);<br><span class="notranslate"></span></p><br> Como puede ver, lee la información en el mismo orden en que la lee en el búfer. Para obtener más información sobre cómo agregar y eliminar datos del búfer, consulte la sección de <b>ejemplos a</b> continuación. </div><br><a name="buffer_alignment" id="buffer_alignment"></a> <label class=
"collapse" for="four">Alineación de búfer</label> <input id="four"
type="checkbox"><div class="index_list"> Si ha estado leyendo esta página, habrá visto referencias a la <b>alineación</b> de <b>bytes</b> de un búfer. Esto básicamente se refiere a la <i>posición en la</i> que se almacenarán los nuevos datos dentro de un buffer determinado. ¿Como funciona esto? Bueno, para un búfer alineado con un solo byte, cada dato se escribe en el búfer de forma secuencial, y cada nueva pieza de datos se agrega directamente después de la anterior. Sin embargo, un búfer alineado con 2 bytes escribirá cada fragmento de datos en intervalos de 2 bytes, por lo que incluso si su escritura inicial es de 1 byte de datos, la <i>siguiente</i> escritura se moverá para alinearse a dos bytes. <img class="center" src=
"images/buffer_byte_alignment.png" alt="Alineación de Byte Buffer"> Entonces, si su alineación de bytes está configurada en, digamos, 4 bytes y usted escribe una sola pieza de datos que tiene un tamaño de 1 byte, haga una <i>indicación de búfer</i> (un <b>contador</b> obtiene la posición actual para leer / escribir para el búfer), usted obtendrá un <i>desplazamiento</i> de 1 (el desplazamiento en este caso es el número de bytes desde el inicio del búfer hasta la posición de lectura / escritura actual). <br><br> Sin embargo, si escribe otro dato, también 1 byte de tamaño, <i>luego</i> realice un buffer buffer, obtendrá un desplazamiento de 5 bytes (aunque solo haya escrito 2 bytes de datos) ya que la alineación ha <i>rellenado</i> los datos para alinearlo con la alineación del búfer de 4 bytes. <br><br> Básicamente, lo que esto significa es que la alineación solo afectará el <i>lugar en el que se escriben las cosas</i>, por lo que si haces un buffer dices después de escribir algo, devolverá la posición de escritura actual que sigue inmediatamente a los datos que has escrito previamente. Sin embargo, tenga en cuenta que si luego escribe otro dato, internamente el búfer moverá la posición de escritura junto con el siguiente múltiplo del tamaño de alineación antes de escribir realmente la información. </div><br><a name="buffer_examples" id="buffer_examples"></a> <label class=
"collapse" for="five">Ejemplos de amortiguamiento</label> <input id="five"
type="checkbox"><div class="index_list"> A continuación puede encontrar algunos ejemplos de usos comunes para los buffers. <br><br><a name="buffer_checkpoint" id="buffer_checkpoint"></a> <label class="collapse" for="six">Hacer un punto de control</label> <input id="six" type="checkbox"><div class="index_list"> Un simple ejemplo de cómo se puede usar un buffer en cualquier juego de <i><span class="notranslate">GameMaker Studio 2</span></i> para cualquier plataforma, es la función <a href=
"../../3_scripting/4_gml_reference/game/game_save_buffer.html"><tt>game_save_buffer</tt></a>. Esta función tomará una &quot;instantánea&quot; del estado del juego actual y lo guardará en un búfer predefinido, que luego podrá leer para cargar el juego en ese punto nuevamente. <br><br><div class="note"> <b>NOTA:</b> Esta función es muy limitada y está diseñada para que el principiante pueda poner en marcha rápidamente un sistema de punto de control, pero los usuarios más avanzados pueden preferir codificar su propio sistema utilizando las <a href=
"../../3_scripting/4_gml_reference/file%20handling/index.html">funciones de archivo</a>, debido a que el juego no se guardará. cualquiera de los recursos dinámicos que puede crear en tiempo de ejecución como estructuras de datos, superficies, fondos agregados y sprites, etc. </div><br> Lo primero que debemos hacer es crear un nuevo objeto para controlar el guardado y la carga, por lo que debería crear uno y darle un <b>evento de creación</b>. En este caso, puede colocar el siguiente código: <br><br><p class="code">SaveBuffer = buffer_create(1024, buffer_grow,
1);<br>
StateSaved = false;<br><span class="notranslate"></span></p><br> La primera línea crea un buffer de <b>crecimiento</b> (ya que no conocemos el tamaño final de los datos guardados) de 1024 bytes y alineado a 1 byte. Luego se crea una variable para verificar y ver si el juego se ha guardado o no (esto se usará para cargar). <br><br> A continuación, agregamos un <b>evento Keypress</b> (por ejemplo) en el que <b>guardaremos</b> el estado actual del juego en el búfer creado: <br><br><p class="code">StateSaved = true;<br>
buffer_seek(SaveBuffer, buffer_seek_start, 0);<br>
game_save_buffer(SaveBuffer);<br><span class="notranslate"></span></p><br> Lo anterior primero establecerá la variable de control en verdadero (para que esto se guarde cuando guardamos el juego en el búfer) y luego <i>buscará</i> el inicio del búfer antes de escribir el estado de salvar actual en él. ¿Por qué usamos <a href=
"../../3_scripting/4_gml_reference/buffers/buffer_seek.html"><tt>buffer_seek</tt></a> ? Bueno, como se menciona en la sección anterior <b>Tipos de datos</b> del <b>búfer</b>, lee y escribe en un búfer desde la última posición en que se le agregaron los datos. Esto significa que si no se establece el buffer <i>diga</i> de nuevo al comienzo y luego cuando se guarda se le añade los datos en el búfer en el búfer en la posición de lectura / escritura, por lo que utilizar la función <tt>buffer_seek</tt> para mover el <i>tell</i> al inicio del buffer. <br><br> Ahora hemos guardado el estado actual del juego en un buffer. El siguiente paso sería codificar cómo cargarlo, probablemente en otro <b>evento Keypress</b>: <br><br><p class="code">if StateSaved<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;buffer_seek(SaveBuffer, buffer_seek_start,
0);<br>
&nbsp;&nbsp;&nbsp;game_load_buffer(SaveBuffer);<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> El juego se cargará al final del evento en el que coloque el código anterior. <br><br><div class="note"> <b>NOTA: ¡</b> Esto es solo para usar en la misma sala, y no para generar juegos completos guardados para después de que tu juego haya sido cerrado o reiniciado! </div><br> Lo último para agregar al objeto controlador es un código de &quot;limpieza&quot;. Los búferes se almacenan en la memoria y, como tales, si no los limpia cuando termina con ellos, puede tener pérdidas de memoria que eventualmente retrasarán y colapsarán su juego. Por lo tanto, probablemente agregaría un <b>Evento de fin de sala</b> (desde la categoría <b>Otro</b> evento) con: <br><br><p class="code">buffer_delete(SaveBuffer);<span class="notranslate"></span></p><br> Este objeto ahora se puede colocar en una habitación y con la tecla presionar guardar y cargar el estado de la habitación desde un búfer. <br><br></div><br><a name="buffer_networking" id="buffer_networking"></a> <label class="collapse" for="seven">Buffers de red</label> <input id="seven" type="checkbox"><div class="index_list"> Al trabajar con las funciones de red de <i><span class="notranslate">GameMaker Studio</span> 2</i>, debe usar almacenamientos intermedios para crear el <i>paquete de</i> datos que se envía a través de la conexión de red. Este ejemplo intenta mostrar cómo se hace esto, pero debido al alcance de las posibilidades de red, solo está diseñado para mostrar cómo usar los buffers, y no el sistema de red completo. <br><br> Lo primero que mostraremos es la creación y el uso de un búfer para el lado del cliente de la conexión de red. Este búfer se usará para crear pequeños paquetes de datos que luego se pueden enviar al servidor, por lo que en el <b>evento Crear</b> de una instancia asignaríamos un búfer como este: <br><br><p class="code">send_buff = buffer_create(256, buffer_grow, 1);<span class="notranslate"></span></p><br> Hacemos que el búfer sea pequeño (256 bytes), ya que no está destinado a almacenar grandes cantidades de datos, lo convertimos en un búfer de <i>crecimiento</i> para garantizar que no haya errores, si necesitamos agregar más datos para enviar en cualquier momento, y la alineación está configurada para uno por conveniencia <br><br> Ahora, digamos que queremos que nuestro cliente envíe datos al servidor. Para eso tenemos que crear un &quot;paquete&quot; de memoria intermedia, y en este ejemplo vamos a enviar un <b>evento de prensa clave</b>, como cuando el jugador presiona la <b>flecha izquierda</b> para moverse por el juego. Para hacer esto, escribimos los datos necesarios en el búfer primero y luego los enviamos: <br><br><p class="code">buffer_seek(buff, buffer_seek_start, 0);<br>
buffer_write(buff, buffer_u8, 1);<br>
buffer_write(buff, buffer_s16, vk_left);<br>
buffer_write(buff, buffer_bool, true);<br>
network_send_packet(client, buff, buffer_tell(buff));<br><span class="notranslate"></span></p><br> Antes de escribir en el búfer, hemos establecido &quot;tell&quot; en el inicio del búfer ya que la red <i>siempre</i> toma los datos desde el <b>inicio</b> de un búfer. Luego escribimos el valor de <i>verificación</i> (esto será utilizado por el servidor para determinar el tipo de evento que se procesará), luego la clave que se usa y luego el estado de la clave (en este caso <tt>true</tt> para presionar). Este búfer se envía como un paquete de datos por la función de red. Tenga en cuenta que <i>no</i> enviamos todo el buffer! Solo enviamos los datos escritos, usando el <a href=
"../../3_scripting/4_gml_reference/buffers/buffer_tell.html"><tt>buffer_tell</tt></a> función para devolver la posición actual de lectura / escritura del búfer (recuerde que escribir en el búfer mueve el &quot;tell&quot; hasta el final de lo que se ha escrito). <br><br> ¿Qué hay de recibir los datos en el servidor? El paquete de datos recibido que se debe escribir en el búfer en el servidor y luego se usa para actualizar el juego. Para eso, <a href=
"../../2_interface/1_editors/events/async_events.html">usaríamos el evento asincrónico de red</a> en el objeto controlador de red del servidor, ya que este código simplificado a continuación muestra: <br><br><p class="code">var buff = ds_map_find_value(async_load,
"buffer");<br>
if cmd == buffer_read(buff, buffer_u8);<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;key = buffer_read(buff, buffer_s16 );<br>
&nbsp;&nbsp;&nbsp;key_state = buffer_read(buff, buffer_bool);<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> El evento asíncrono contendrá un especial temporal <tt>ds_map</tt> (se elimina al final del evento automáticamente) que contiene información diferente según el tipo de datos entrantes de la red. En este caso, asumimos que el mapa se ha verificado y se ha encontrado que es un paquete de datos de búfer enviado por un cliente. Ahora comprobamos la primera información que está en el búfer para ver qué tipo de evento se ha enviado; en este caso, el valor &quot;1&quot; representa un evento <i>clave</i>, sin embargo, al codificar estas cosas, debe definir <b>constantes</b> para mantener estos valores en simplifique las cosas, y luego almacene la tecla presionada y su estado ( <tt>true</tt> = presionado, <tt>false</tt> = liberado). Esta información luego se usaría para actualizar a todos los clientes con el nuevo estado del reproductor cliente remitente. <br><br><div class="note"> <b>NOTA:</b> El buffer que se crea desde ds_map se elimina automáticamente al final del evento asincrónico de red, por lo que no es necesario utilizar <a href=
"../../3_scripting/4_gml_reference/buffers/buffer_delete.html"><tt>buffer_delete</tt></a> aquí. </div></div></div></blockquote><p><br></p></div><div class="footer"><div class="buttons"><div class="clear"><div style="float:left"> Atrás: <a href="index.html">Índice de información adicional</a> </div><div style="float:right"> Siguiente: <a href="texture_pages.html">Páginas de textura</a> </div></div></div><h5> © Copyright <span class="notranslate">YoYo Games Ltd.</span> 2017 Todos los derechos reservados </h5>
<script type="text/javascript">
   (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');   ga('create', 'UA-2711665-14', 'auto');   ga('send', 'pageview'); 
</script>
</div>

<script type="text/JavaScript">
var fe = FindFrame("toc", top);
if ((fe != null) && (chmtop.c2wtopf.jstree != null)) {
  if (chmtop.c2wtopf.FITEMS[chmtop.c2wtopf.pagenum] != chmtop.c2wtopf.pageid)
    chmtop.c2wtopf.jstree.OpenTreeNode("source/" + chmtop.c2wtopf.pageid);
}
</script>
</body>
</html>

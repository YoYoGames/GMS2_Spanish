<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="keywords" content="online documentation, web online help, web help, chm2web" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="generator" content="chm2web Pro 2.85 (unicode)" />
<title>Using Buffers</title>
<meta http-equiv="X-UA-Compatible" content="IE=9">

<link rel="stylesheet" href="../../../../files/helpindex.css" type=
"text/css">
<link rel="stylesheet" href="../../../../default.css" type=
"text/css">

<script type="text/JavaScript" src="../../../../files/supply.js"></script>
<script type="text/JavaScript">
chmtop.c2wtopf.pageid = "_build/1_overview/3_additional_information/using_buffers.html";
</script>

</head>
<body><script type="text/JavaScript"> 
if (window.name != "content") 
  document.write(" <table width=\"100%\" bgcolor=\"#e1e1e1\"cellspacing=\"2\" cellpadding=\"0\" style=\"border-collapse: collapse; font-family: sans-serif; font-size: 14px; color: #000000; text-decoration: none;  \"> <tr> <td align=\"center\" style=\"border-bottom: 2px solid gray\" > <br>&nbsp;Click <a href=\"../../../../index.html?page=source%2F_build%2F1_overview%2F3_additional_information%2Fusing_buffers.html\">here</a> to show toolbars of the Web Online Help System: <a href=\"../../../../index.html?page=source%2F_build%2F1_overview%2F3_additional_information%2Fusing_buffers.html\">show toolbars</a><br>&nbsp;</td></tr></table><br> "); 
</script>
<!-- !chm2web! --><script type="text/JavaScript">
 if( typeof(chmtop.helpStyle) != 'undefined' ) { var linkNodes = document.getElementsByTagName("link");  for( var i=0; i < linkNodes.length; ++i ) { var link = linkNodes[i];    if( link.href.endsWith("default.css")) {    var style = link.href.replace("default.css", chmtop.helpStyle); document.write('<link id="newstyleLink" rel="stylesheet" href=' + style + ' type="text/css">');    break; } } } 
</script><h2> Utilizando Buffers </h2><div class="body-scroll"><p><br></p><p> <i><span class="notranslate">GameMaker Studio 2</span></i> tiene una serie de funciones en GML para lidiar con los <b>buffers</b>. La mayoría de las personas deben estar familiarizadas con este término, ya que se usa todo el tiempo cuando se trata de computadoras y programación, pero saber la palabra no significa que realmente sepa lo que significa. Entonces, esta página pretende explicar qué es un búfer y cómo usarlos en el contexto de la programación de <i><span class="notranslate">GameMaker Studio 2</span></i>, aunque la forma general en que funcionan es la misma, sin importar el idioma o la tecnología, que es una de las razones por las que son muy importante. </p><blockquote><a name="buffers" id="buffers"></a> <label class=
"collapse" for="one">¿Qué es un búfer?</label> <input id="one"
type="checkbox"><div class="index_list"> Un búfer (en programación) es básicamente un espacio dentro de la memoria del sistema que se utiliza para almacenar pequeños <i>paquetes</i> de datos para casi cualquier cosa (por ejemplo, transferencia de datos, colisiones, datos de color, etc.). Dado que se guarda en la memoria del sistema, el acceso es muy rápido y generalmente se usaría un búfer para el almacenamiento a muy corto plazo, como recibir información de la red antes de procesarla, o para almacenar un punto de control en su juego (esto se explica en la ejemplo dado más abajo en la página). <img class="center" src=
"images/buffer_memory.png" alt="Memoria búfer"> Los búferes se crean asignando un espacio en la memoria del sistema, calculado en <b>bytes</b>, que luego se reserva para su juego siempre y cuando el juego se esté ejecutando o hasta que elimine el búfer utilizando la función apropiada. Esto significa que incluso cuando su juego no está enfocado (por ejemplo, en un dispositivo móvil cuando atiende una llamada, el juego se pondrá en segundo plano) el búfer seguirá existiendo, sin embargo, si el juego se cierra o se reinicia, el búfer se perderá. <br><br><div class="note"> <b>NOTA: ¡</b> Reiniciar el juego no borrará o eliminará el búfer! Pero evitará que se habrá perdido cualquier nuevo acceso a la memoria intermedia creada anteriormente como el <b>mango</b> Identificación, causando una pérdida de memoria, que se colgará su juego con el tiempo. Por lo tanto, cuando reinicies un juego, recuerda eliminar primero el búfer. </div></div><br><a name="buffer_types" id="buffer_types"></a> <label class=
"collapse" for="two">Tipos de búfer</label> <input id="two" type=
"checkbox"><div class="index_list"> <i><span class="notranslate">GameMaker Studio 2</span></i> permite la creación de cuatro tipos de búfer diferentes. El motivo de esto es que los búferes están diseñados para ser un medio de almacenamiento temporal altamente optimizado, y como tal, debe crear un búfer que sea apropiado para el tipo de datos que desea almacenar, de lo contrario, podría obtener errores o causar un <i>cuello de botella.</i> en su codigo Antes de explicar esto más a fondo, veamos los cuatro tipos de búfer disponibles (definidos como <b>constantes</b> en GML): <br><br><div class="compat"><table><tr><th> Constante </th><th> descripción </th></tr><tr><td> <span class="notranslate">buffer_fixed</span> </td> <td><br> Un búfer de un tamaño fijo en bytes. El tamaño se establece cuando se crea el búfer y no se puede cambiar de nuevo. <br><br></td></tr><tr class="alt"><td> <span class="notranslate">buffer_grow</span> </td> <td><br> Un buffer que <i>crecerá</i> dinámicamente a medida que se agreguen datos. Lo creas con un tamaño inicial (que debería ser una aproximación del tamaño de los datos que se espera almacenar), y luego se expandirá para aceptar más datos que desborden este tamaño inicial. <br><br></td></tr><tr><td> <span class="notranslate">buffer_wrap</span> </td> <td><br> Un buffer donde los datos se <i>envuelva.</i> Cuando los datos que se agreguen alcancen el límite del tamaño del búfer, la sobrescritura se volverá a colocar al inicio del búfer, y la escritura continuará desde ese punto. <br><br></td></tr><tr class="alt"><td> <span class="notranslate">buffer_fast</span> </td> <td><br> Este es un búfer especial &quot;reducido&quot; que es extremadamente rápido de leer / escribir. Sin embargo, solo se puede utilizar con <tt>buffer_u8</tt> tipos de datos, y debe estar 1 byte alineado. (La información sobre <b>los tipos de datos</b> y la <b>alineación de bytes</b> se puede encontrar más abajo en esta página). <br><br></td></tr></table></div><br><br> Esos son los tipos de búfer disponibles para ti cuando usas <i><span class="notranslate">GameMaker</span> Studio 2</i>, y el que elijas dependerá en gran medida del uso que desees. Por ejemplo, un búfer de <b>crecimiento</b> se usaría para almacenar una &quot;instantánea&quot; de datos para crear una partida segura ya que no conoce la cantidad real de datos que se colocarán en él, o se usaría un búfer <b>rápido</b> cuando sepa que los valores con los que está trabajando están todos entre 0 y 255 o -128 y 127, por ejemplo, al procesar datos RGB de una imagen. <img class="center" src="images/buffer_types.png" alt="Tipos de búfer"> Al crear un búfer, siempre debe intentar crearlo a un tamaño que sea apropiado para el tipo, con la regla general de que debe crearse para adaptarse al tamaño máximo de datos que debe almacenar, y en caso de duda, utilizar un búfer de <b>crecimiento</b> para evitar errores de sobrescritura. <br><br> El código real para crear un búfer se vería así: <br><br><p class="code">player_buffer = buffer_create(16384, buffer_fixed,
2);<span class="notranslate"></span></p><br> Eso crearía un búfer fijo de 16384 bytes y un <b>byte alineado</b> a 2, con la función devolviendo un valor de <b>id</b> único que se almacena en una variable para futuras referencias a este búfer. Ahora tenemos el concepto básico de un búfer explicado que debe conocer sobre <b>los tipos de datos</b> y la <b>alineación de bytes</b> mencionada anteriormente. </div><br><a name="buffer_data_types" id="buffer_data_types"></a> <label class="collapse" for="three">Tipos de datos de búfer</label> <input id="three" type="checkbox"><div class="index_list"> Al leer y escribir datos en un búfer, lo hace en &#39;&#39; trozos &#39;&#39; de datos definidos por su &#39;&#39; &#39;tipo de datos&#39; &#39;&#39;. El &#39;&#39; &#39;tipo de datos&#39; &#39;&#39; establece el número de bytes asignados dentro del búfer para el valor que se está escribiendo, y es esencial que lo hagas correctamente, de lo contrario obtendrás resultados muy extraños (o incluso errores) para tu código. <br><br> Los buffers se escriben (y se leen) <i>secuencialmente</i>, en el sentido de que una parte de los datos se escribe después de otra, y cada parte de los datos es de un tipo determinado. Esto significa que, idealmente, deberías conocer qué datos estás escribiendo en el búfer en todo momento. Estos <b>tipos de datos</b> se definen en GML por las siguientes <i>constantes</i>: <div class="compat"><table><tr><th> Tipo de datos constante </th><th> Bytes </th><th> Descripción </th></tr><tr><td> buffer_u8 </td><td> 1 </td><td><br> Un entero de 8 bits sin signo. Este es un valor positivo de 0 a 255. <br><br></td></tr><tr class="alt"><td> buffer_s8 </td><td> 1 </td><td><br> Un entero de 8 bits con signo. Este puede ser un valor positivo o negativo de -128 a 127 (0 se clasifica como positivo). <br><br></td></tr><tr><td> buffer_u16 </td><td> 2 </td><td><br> Un entero sin signo, de 16 bits. Este es un valor positivo de 0 - 65,535. <br><br></td></tr><tr class="alt"><td> buffer_s16 </td><td> 2 </td><td><br> Un entero de 16 bits con signo. Este puede ser un valor positivo o negativo de -32,768 a 32,767 (0 se clasifica como positivo). <br><br></td></tr><tr><td> buffer_f16 </td><td> 2 </td><td><br> Un número de punto flotante de 16 bits. Esto puede ser un valor positivo o negativo dentro del rango de +/- 65504. <b>(Actualmente no se admite)</b> <br><br></td></tr><tr><td> buffer_u32 </td><td> 4 </td><td><br> Un entero de 32 bits sin signo. Este es un valor positivo de 0 a 4,294,967,295. <br><br></td></tr><tr class="alt"><td> buffer_s32 </td><td> 4 </td><td><br> Un entero de 32 bits con signo. Este puede ser un valor positivo o negativo de -2,147,483,648 a 2,147,483,647 (0 se clasifica como positivo). <br><br></td></tr><tr><td> buffer_f32 </td><td> 4 </td><td><br> Un número de punto flotante de 32 bits. Este puede ser un valor positivo o negativo dentro del rango de +/- 16777216. <br><br></td></tr><tr class="alt"><td> buffer_u64 </td><td> 8 </td><td><br> Un valor entero sin signo de 64 bits. <b>(Actualmente no es compatible con todas las funciones de búfer)</b> <br><br></td></tr><tr><td> buffer_f64 </td><td> 8 </td><td><br> Un número de punto flotante de 64 bits. <br><br></td></tr><tr class="alt"><td> buffer_bool </td><td> 1 </td><td><br> Un valor booleano. Solo puede ser 1 o 0 ( <tt>true</tt> o <tt>false</tt> ) <br><br></td></tr><tr><td> buffer_string </td><td> N / A </td><td><br> Esta es una cadena terminada en nulo UTF-8 (0x00). Básicamente, una cadena de <span class="notranslate">GameMaker</span> se descarga en el búfer y se pone un 0 al final. <br><br></td></tr></table></div><br><br> Entonces, digamos que ha creado un búfer y desea escribir información en él, entonces usaría algo como el siguiente código: <br><br><p class="code">buffer_write(buff, buffer_bool, global.Sound);<br>
buffer_write(buff, buffer_bool, global.Music);<br>
buffer_write(buff, buffer_s16, obj_Player.x);<br>
buffer_write(buff, buffer_s16, obj_Player.y);<br>
buffer_write(buff, buffer_string, global.Player_Name);<br><span class="notranslate"></span></p><br> mirando el ejemplo anterior, puede ver que puede escribir diferentes tipos de datos en un búfer (solo está limitado a un tipo de datos específico cuando se usa el tipo de búfer <b>rápido</b> ), y estos datos se agregarán al búfer consecutivamente (aunque la posición real en el búfer dependerá de su <b>alineación de bytes</b>, que se explica a continuación). Esto es lo mismo para leer la información del búfer también, y en el caso del ejemplo dado anteriormente, leería del búfer en el mismo orden en que escribió los datos, verificando el mismo tipo de datos, por ejemplo: <br><br><p class="code">global.Sound = buffer_read(buff, buffer_bool);<br>
global.Music = buffer_read(buff, buffer_bool);<br>
obj_Player.x = buffer_read(buff, buffer_s16);<br>
obj_Player.y = buffer_read(buff, buffer_s16);<br>
global.Player_Name = buffer_read(buff, buffer_string);<br><span class="notranslate"></span></p><br> Como puede ver, lee la información en el mismo orden en que la lee en el búfer. Para obtener más información sobre cómo agregar y eliminar datos del búfer, consulte la sección de <b>ejemplos a</b> continuación. </div><br><a name="buffer_alignment" id="buffer_alignment"></a> <label class=
"collapse" for="four">Alineación de búfer</label> <input id="four"
type="checkbox"><div class="index_list"> Si ha estado leyendo esta página, habrá visto referencias a la <b>alineación</b> de <b>bytes</b> de un búfer. Básicamente, esto se refiere a la <i>posición en la</i> que se almacenarán los nuevos datos dentro de un búfer dado. ¿Como funciona esto? Bueno, para un búfer alineado de un solo byte, cada dato se escribe en el búfer de forma secuencial, con cada dato nuevo que se agrega directamente después del anterior. Sin embargo, un búfer alineado de 2 bytes escribirá cada fragmento de datos a intervalos de 2 bytes, de modo que incluso si su escritura inicial es de 1 byte de datos, la <i>siguiente</i> escritura se moverá para alinearse con dos bytes. <img class="center" src=
"images/buffer_byte_alignment.png" alt="Alineación de bytes de búfer"> Por lo tanto, si su alineación de bytes se establece en, digamos, 4 bytes y escribe una sola pieza de datos que tiene un tamaño de 1 byte, entonces haga un <i>aviso de búfer</i> (a <b>tell</b> obtiene la posición actual para leer / escribir para el búfer), Obtendré un <i>desplazamiento</i> de 1 (el desplazamiento en este caso es el número de bytes desde el inicio del búfer hasta la posición de lectura / escritura actual). <br><br> Sin embargo, si escribe otra parte de datos, también de 1 byte de tamaño, <i>luego</i> hace un informe de búfer, obtendrá un desplazamiento de 5 bytes (aunque solo haya escrito 2 bytes de datos) ya que la alineación ha <i>rellenado</i> los datos para alinearlo con la alineación de búfer de 4 bytes. <br><br> Básicamente, lo que esto significa es que la alineación solo afectará el lugar <i>donde se escriben las cosas</i>, por lo que si hace un informe de búfer después de escribir algo, devolverá la posición de escritura actual que sigue inmediatamente a los datos que escribió anteriormente. Tenga en cuenta, sin embargo, que si luego escribe otra parte de los datos, internamente el búfer moverá la posición de escritura a lo largo del siguiente múltiplo del tamaño de alineación antes de escribir la parte de los datos. </div><br><a name="buffer_examples" id="buffer_examples"></a> <label class=
"collapse" for="five">Ejemplos de búfer</label> <input id="five"
type="checkbox"><div class="index_list"> A continuación puede encontrar algunos ejemplos de usos comunes para buffers. <br><br><a name="buffer_checkpoint" id="buffer_checkpoint"></a> <label class="collapse" for="six">Haciendo un punto de control</label> <input id="six" type="checkbox"><div class="index_list"> Un ejemplo simple de cómo se puede usar un búfer en cualquier juego de <i><span class="notranslate">GameMaker Studio 2</span></i> para cualquier plataforma, es la función <a href=
"../../3_scripting/4_gml_reference/game/game_save_buffer.html"><tt>game_save_buffer</tt></a>. Esta función tomará una &quot;instantánea&quot; del estado actual del juego y la guardará en un búfer predefinido, que luego se puede leer para cargar el juego nuevamente en ese punto. <br><br><div class="note"> <b>NOTA:</b> esta función es muy limitada y está diseñada para que el principiante pueda poner en funcionamiento un sistema de punto de control rápidamente, pero los usuarios más avanzados pueden preferir codificar su propio sistema utilizando las <a href=
"../../3_scripting/4_gml_reference/file%20handling/index.html">funciones de Archivo</a>, debido a que el juego no se guardará cualquiera de los recursos dinámicos que puede crear en tiempo de ejecución, como estructuras de datos, superficies, fondos agregados y sprites, etc. </div><br> Lo primero que debemos hacer es crear un nuevo objeto para controlar el guardado y la carga, para que pueda crear uno y darle un <b>evento Crear</b>. En este caso, podría colocar el siguiente código: <br><br><p class="code">SaveBuffer = buffer_create(1024, buffer_grow,
1);<br>
StateSaved = false;<br><span class="notranslate"></span></p><br> La primera línea crea un búfer de <b>crecimiento</b> (ya que no conocemos el tamaño final de los datos guardados) de 1024 bytes y se alinea a 1 byte. Luego se crea una variable para verificar y ver si el juego se ha guardado o no (esto se usará para cargar). <br><br> A continuación, agregaremos un <b>evento Keypress</b> (por ejemplo) en el que <b>guardaremos</b> el estado actual del juego en el búfer creado: <br><br><p class="code">StateSaved = true;<br>
buffer_seek(SaveBuffer, buffer_seek_start, 0);<br>
game_save_buffer(SaveBuffer);<br><span class="notranslate"></span></p><br> Lo anterior primero establecerá la variable de control en verdadero (para que esto se guarde cuando guardemos el juego en el búfer) y luego <i>buscaremos</i> el inicio del búfer antes de escribir el estado de guardado actual en él. Porque usamos <a href=
"../../3_scripting/4_gml_reference/buffers/buffer_seek.html"><tt>buffer_seek</tt></a> ? Bueno, como se mencionó en la sección anterior de <b>Tipos de datos de búfer</b>, usted lee y escribe en un búfer desde la última posición en que se le agregaron los datos. Esto significa que si no se establece el buffer <i>diga</i> de nuevo al comienzo y luego cuando se guarda se le añade los datos en el búfer en el búfer en la posición de lectura / escritura, por lo que utilizar la función <tt>buffer_seek</tt> Para mover el <i>tell</i> al inicio del buffer. <br><br> Ahora hemos guardado el estado actual del juego en un búfer. El siguiente paso sería codificar cómo cargarlo, probablemente en otro <b>evento Keypress</b>: <br><br><p class="code">if StateSaved<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;buffer_seek(SaveBuffer, buffer_seek_start,
0);<br>
&nbsp;&nbsp;&nbsp;game_load_buffer(SaveBuffer);<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> El juego se cargará al final del evento en el que colocas el código anterior. <br><br><div class="note"> <b>NOTA: ¡</b> Esto es solo para usar en la misma habitación, y no para generar juegos guardados completos después de que el juego se haya cerrado o reiniciado! </div><br> Lo último que se agrega al objeto del controlador es un código de &quot;limpieza&quot;. Los búferes se almacenan en la memoria y, como tal, si no realiza una limpieza cuando termina con ellos, puede obtener pérdidas de memoria que eventualmente retrasarán y bloquearán su juego. Por lo tanto, probablemente agregaría un <b>Evento de fin de sala</b> (de la categoría <b>Otro</b> evento) con: <br><br><p class="code">buffer_delete(SaveBuffer);<span class="notranslate"></span></p><br> Este objeto ahora se puede colocar en una habitación y al presionar una tecla, guardar y cargar el estado de la habitación desde un búfer. <br><br></div><br><a name="buffer_networking" id="buffer_networking"></a> <label class="collapse" for="seven">Red Buffers</label> <input id="seven" type="checkbox"><div class="index_list"> Cuando trabaje con las funciones de red de <i><span class="notranslate">GameMaker Studio</span> 2</i>, debe usar buffers para crear el <i>paquete de</i> datos que se envía a través de la conexión de red. Este ejemplo pretende mostrar cómo se hace esto, pero debido al alcance de las posibilidades de red, solo está diseñado para mostrar cómo usar los buffers, y no el sistema de red completo. <br><br> Lo primero que mostraremos es la creación y el uso de un búfer para el lado del cliente de la conexión de red. Este búfer se utilizará para crear pequeños paquetes de datos que luego se pueden enviar al servidor, por lo que en el <b>evento Crear</b> de una instancia asignaremos un búfer como este: <br><br><p class="code">send_buff = buffer_create(256, buffer_grow, 1);<span class="notranslate"></span></p><br> Hacemos que el búfer sea pequeño (256 bytes) ya que no está diseñado para almacenar grandes cantidades de datos, lo hacemos un búfer de <i>crecimiento</i> para asegurarnos de que no debemos agregar más datos en cualquier momento, y la alineación se establece en uno por conveniencia. <br><br> Ahora, digamos que queremos que nuestro cliente envíe datos al servidor. Para eso necesitamos crear un &quot;paquete&quot; de búfer, y en este ejemplo enviaremos un <b>evento de pulsación de tecla</b>, como cuando el jugador presiona la <b>flecha izquierda</b> para moverse por el juego. Para hacer esto, primero escribimos los datos necesarios en el búfer y luego los enviamos: <br><br><p class="code">buffer_seek(buff, buffer_seek_start, 0);<br>
buffer_write(buff, buffer_u8, 1);<br>
buffer_write(buff, buffer_s16, vk_left);<br>
buffer_write(buff, buffer_bool, true);<br>
network_send_packet(client, buff, buffer_tell(buff));<br><span class="notranslate"></span></p><br> Antes de escribir en el búfer, hemos configurado &quot;indicar&quot; el inicio del búfer, ya que las redes <i>siempre</i> toman los datos del <b>inicio</b> de un búfer. Luego escribimos el valor de <i>verificación</i> (el servidor lo utilizará para determinar el tipo de evento que se procesará), luego la clave que se está utilizando y luego el estado de la clave (en este caso <tt>true</tt> para presionar). Este búfer se envía como un paquete de datos por la función de red. Tenga en cuenta que <i>no</i> enviamos todo el búfer! Solo enviamos los datos escritos, utilizando el <a href=
"../../3_scripting/4_gml_reference/buffers/buffer_tell.html"><tt>buffer_tell</tt></a> función para devolver la posición actual de lectura / escritura del búfer (recuerde que escribir en el búfer mueve el &quot;tell&quot; al final de lo que se ha escrito). <br><br> ¿Qué hay de recibir los datos en el servidor? El paquete de datos recibido que debe escribirse en el búfer en el servidor y luego usarse para actualizar el juego. Para eso <a href=
"../../2_interface/1_editors/events/async_events.html">usaríamos el evento asíncrono de red</a> en el objeto del controlador de red del servidor, como se muestra a continuación en este código simplificado: <br><br><p class="code">var buff = ds_map_find_value(async_load,
"buffer");<br>
if cmd == buffer_read(buff, buffer_u8);<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;key = buffer_read(buff, buffer_s16 );<br>
&nbsp;&nbsp;&nbsp;key_state = buffer_read(buff, buffer_bool);<br>
&nbsp;&nbsp;&nbsp;}<br><span class="notranslate"></span></p><br> El evento asíncrono contendrá un temporal especial. <tt>ds_map</tt> (se elimina automáticamente al final del evento) que contiene información diferente según el tipo de datos entrantes de la red. En este caso, estamos asumiendo que el mapa se ha verificado y se encontró que es un paquete de datos de búfer enviado desde un cliente. Ahora verificamos la primera parte de los datos que están en el búfer para ver qué tipo de evento se ha enviado. En este caso, el valor &quot;1&quot; representa un evento <i>clave</i>. Sin embargo, al codificar estas cosas, debe definir <b>constantes</b> para mantener estos valores. simplifique las cosas, y luego almacene la tecla que está presionando y su estado ( <tt>true</tt> = presionado, <tt>false</tt> = liberado). Esta información se usaría para actualizar a todos los clientes con el nuevo estado del reproductor cliente que envía. <br><br><div class="note"> <b>NOTA:</b> El búfer que se crea a partir de ds_map se elimina automáticamente al final del evento asíncrono de la red, por lo que no es necesario utilizar <a href=
"../../3_scripting/4_gml_reference/buffers/buffer_delete.html"><tt>buffer_delete</tt></a> aquí. </div></div></div></blockquote><p><br></p></div><div class="footer"><div class="buttons"><div class="clear"><div style="float:left"> Atrás: <a href="index.html">Indice de Información Adicional</a> </div><div style="float:right"> Siguiente: <a href="texture_pages.html">Páginas de textura</a> </div></div></div><h5>© Copyright YoYo Games Ltd. 2018 All Rights Reserved</h5>
<script type="text/javascript">
   (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');   ga('create', 'UA-2711665-14', 'auto');   ga('send', 'pageview'); 
</script>
</div>

<script type="text/JavaScript">
var fe = FindFrame("toc", top);
if ((fe != null) && (chmtop.c2wtopf.jstree != null)) {
  if (chmtop.c2wtopf.FITEMS[chmtop.c2wtopf.pagenum] != chmtop.c2wtopf.pageid)
    chmtop.c2wtopf.jstree.OpenTreeNode("source/" + chmtop.c2wtopf.pageid);
}
</script>
</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="keywords" content="online documentation, web online help, web help, chm2web" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="generator" content="chm2web Pro 2.85 (unicode)" />
<title>Bitwise Operators And Binary</title>
<meta http-equiv="X-UA-Compatible" content="IE=9">

<link rel="stylesheet" href="../../../../files/helpindex.css" type=
"text/css">
<link rel="stylesheet" href="../../../../default.css" type=
"text/css">

<script type="text/JavaScript" src="../../../../files/supply.js"></script>
<script type="text/JavaScript">
chmtop.c2wtopf.pageid = "_build/1_overview/3_additional_information/bitwise_operators.html";
</script>

</head>
<body><script type="text/JavaScript"> 
if (window.name != "content") 
  document.write(" <table width=\"100%\" bgcolor=\"#e1e1e1\"cellspacing=\"2\" cellpadding=\"0\" style=\"border-collapse: collapse; font-family: sans-serif; font-size: 14px; color: #000000; text-decoration: none;  \"> <tr> <td align=\"center\" style=\"border-bottom: 2px solid gray\" > <br>&nbsp;Click <a href=\"../../../../index.html?page=source%2F_build%2F1_overview%2F3_additional_information%2Fbitwise_operators.html\">here</a> to show toolbars of the Web Online Help System: <a href=\"../../../../index.html?page=source%2F_build%2F1_overview%2F3_additional_information%2Fbitwise_operators.html\">show toolbars</a><br>&nbsp;</td></tr></table><br> "); 
</script>
<!-- !chm2web! --><script type="text/JavaScript">
 if( typeof(chmtop.helpStyle) != 'undefined' ) { var linkNodes = document.getElementsByTagName("link");  for( var i=0; i < linkNodes.length; ++i ) { var link = linkNodes[i];    if( link.href.endsWith("default.css")) {    var style = link.href.replace("default.css", chmtop.helpStyle); document.write('<link id="newstyleLink" rel="stylesheet" href=' + style + ' type="text/css">');    break; } } } 
</script><h2> Operadores bit a bit y binarios </h2><div class="body-scroll"><p><br></p><p> Al comienzo de la era de la informática, el binario y el hexadecimal eran una forma de vida, probablemente porque los lenguajes de alto nivel (como BASIC) eran simplemente demasiado lentos. En estos días, sin embargo, con el poder de la PC más común, ya no tienes que saber nada de esto y puedes hacer las cosas a largo plazo, ya que la velocidad de la máquina y su construcción de CPU más compleja compensarán cualquier corto venideras este enfoque tiene. </p><p> Como un ejemplo muy simple, en el pasado multiplicar por 32 podría haber llevado varios ciclos de CPU para ejecutarse, mientras que una operación binaria simple para hacer lo mismo solo habría tomado 1. A medida que las máquinas se han vuelto más complejas, también han reducido el tiempo muchas instrucciones complejas tardan en ejecutarse, de modo que ahora, una multiplicación de 32x32 bits bien podría tomar solo 1 ciclo, igual que el operador binario. Esta es una gran noticia, por supuesto, ya que significa que ya no tiene que optimizar cada línea de código que escribe, pero si este es el caso, ¿realmente debería preocuparse por el binario? </p><p> La respuesta es definitivamente &quot;sí, deberías&quot;. Si bien es cierto, aún puedes obtener algunas aceleraciones, y algunas veces éstas pueden ser significativas, usando leads binarios y hexadecimales para que conozcas mejor la CPU y también puedas escribir mejor código, poder empacar mejor los datos y realizar algunas tareas. mucho más simple. Esta página explicará un poco sobre qué es binario y cómo se puede usar para hacer tus juegos. </p><blockquote> <label class="collapse" for="one">Teoría de los números</label> <input id="one" type="checkbox"><div class="index_list"> Así que veamos primero la teoría binaria más básica: cómo se crean los números. Eche un vistazo a esta tabla: <br><br><p class="code">000 = 0<br>
001 = 1<br>
010 = 2<br>
100 = 4<br><span class="notranslate"></span></p><br> Cada 1 o 0 representa un solo <i>bit</i> de datos, y como puede ver, esto significa que en binario, 10 es igual a 2! Cada bit es <i>2 veces el valor anterior,</i> siendo el primer bit igual a 1. Entonces bit 2 = 2, bit 3 = 4, bit 4 = 8 y así sucesivamente (como se muestra a continuación en esta tabla de <i>bytes</i> ; un byte es una colección de 8 bits): <br><br><p class="code">00000001 = 1<br>
00000010 = 2<br>
00000100 = 4<br>
00001000 = 8<br>
00010000 = 16<br>
00100000 = 32<br>
01000000 = 64<br>
10000000 = 128<br><span class="notranslate"></span></p><br> Eso está bien si quieres números con un poder de 2, pero ¿cómo creamos números más complejos? Bueno, un solo número binario solo puede almacenar un 0 o 1, y eso es todo, así que para números más complejos necesitamos agregar bits juntos. Si, por ejemplo, quisiéramos hacer 6, sumaríamos 4 y 2 juntos así. <br><br><p class="code">00000010 = 2<br>
00000100 = 4<br>
00000110 = 6<br><span class="notranslate"></span></p><br> Esto es cierto para <i>todos</i> los números binarios, y cómo la computadora compone cualquier número internamente. Tomemos un número un poco más complicado como un ejemplo más: 23. El número 23 en realidad está compuesto por 1 + 2 + 4 + 16 o 00010111. ¿Qué tal un ejemplo mucho más complejo: 196? Bueno, eso está hecho de 128 + 64 + 4 o 11000100. Así que en realidad no es tan complejo realmente. Si comenzamos a hacer valores fuera del rango de un byte (que puede almacenar números del 0 al 255), comienza a ser un poco más difícil de seguir. Por ejemplo, 217,361 es 110101000100010001 en binario. O bien, 1 + 16 + 256 + etc... Las reglas son las mismas independientemente del valor que se exprese: cada número se crea al agregar múltiples bits. </div><br> <label class="collapse" for="two">Operadores Binarios</label> <input id="two" type="checkbox"><div class="index_list"> Ahora, ¿qué significa esto en binario? Bueno, digamos que quieres almacenar una <tt>true</tt> o <tt>false</tt> como un valor Usualmente los compiladores usarán un INT (un INT generalmente se define como un número de 32 bits con signo) y luego simplemente lo asignan a 0 o 1. Sin embargo, teniendo solo 2 estados, un <tt>true</tt> / <tt>false</tt> valor es ideal para almacenar en un poco, y si lo hiciéramos podríamos almacenar 32 <tt>true</tt> / <tt>false</tt> bits para cada INT en lugar de solo uno. <br><br> ¿Cómo haríamos esto? Bien, resulta bastante fácil: <br><br><p class="code">flags = flags | 1;<br><span class="notranslate"></span></p><br> El &quot;|&quot; el operador es un <b>OR a nivel de bits</b>, y esto significa que las instrucciones OR anteriores 1 en indicadores. Si recuerda desde antes, al usar un 1 se establecerá el primer bit. Si quisiéramos establecer el segundo bit, haríamos esto: <br><br><p class="code">flags = flags | 2;<br><span class="notranslate"></span></p><br> Nosotros O en 2, porque el patrón de bits 00000010 es igual a 2. Entonces, ¿qué hace exactamente el operador OR binario? Bueno, combina todos los bits en un solo valor, como este: <br><br><p class="code">010110100<br>
110011001<br>
110111101<br><span class="notranslate"></span></p><p><br> Esto es lo que se conoce como <i>tabla de verdad</i> para el operador OR: <br><br></p><p class="code">00 | 00 = 00<br>
00 | 01 = 01<br>
01 | 01 = 01<br>
01 | 00 = 01<br><span class="notranslate"></span></p><br> Entonces, donde hay un valor con 2 ceros, se mantendrá cero. La ventaja de utilizar BITS como un estado verdadero / falso es que puede establecer varios indicadores en una operación, algo que simplemente no podría hacer con un valor booleano normal. Por ejemplo, digamos que el bit 1 es un indicador &quot;activo&quot;, y el bit 3 es un indicador &quot;visible&quot;. Podríamos establecer <i>ambos</i> haciendo esto: <br><br><p class="code">flags = flags | 5;<br><span class="notranslate"></span></p><br> Esto se debe a que 5 es 00000101 en binario, y siguiendo la regla anterior, la variable &quot;banderas&quot; obtendrá estos dos bits fusionados con los propios. Entonces, incluso si el bit 1 ya estaba configurado, la operación aún funciona y ahora también se establecerá el bit 3. <br><br> ¿Qué hay de borrar banderas? Bueno, aquí es donde entra la operación AND binaria. Cuando AND AND algo, los bits que se establecen en la máscara se mantienen, mientras que los bits que están claros en la máscara se eliminan, como este: <br><br><p class="code">01110010101<br>
00110000100<br>
00110000100<br><span class="notranslate"></span></p><br> Como puede ver, donde hay un poco en cada valor, el bit se mantiene, y donde hay una mezcla de 0 y 1, estos se restablecen a 0. Aquí está la tabla de verdad para ANDing: <br><br><p class="code">00 &amp; 00 = 00<br>
01 &amp; 00 = 00<br>
00 &amp; 01 = 00<br>
01 &amp; 01 = 01<br><span class="notranslate"></span></p><p><br> Por lo tanto, solo cuando haya un poco en cada lugar se mantendrá. Lo que esto significa es que, del mismo modo que puede <i>establecer</i> varias banderas a la vez, también puede <i>borrar</i> varias banderas a la vez. Por ejemplo, tomemos el caso anterior, pero esta vez aclárelos. Queremos borrar los bits 1 y 3 (dándonos el valor 5), pero al recordar la tabla de verdad anterior, lo que queremos hacer es mantener todos los otros bits, y borrar los bits 1 y 3. Esta sería una máscara binaria &quot;de 11111111111111111111111111111010 (32 bits). Esta máscara mantiene todos los bits actualmente configurados, pero borra los dos bits que realmente queremos borrar. Entonces, si tuviera un valor de 1000111011 y quisiera borrar los bits 1 y 3 usando la máscara anterior, terminaría con esto... <br><br></p><p class="code">00000000000000000000001000111011<br>
11111111111111111111111111111010<br>
00000000000000000000001000111010<br><span class="notranslate"></span></p><br> Esto es genial, pero si tuviéramos que resolver esto cada vez que necesitáramos borrar banderas, sería tedioso. Lo que necesitamos es una forma de voltear los bits fácilmente (y preferiblemente sin costo de CPU). Afortunadamente, hay una manera fácil de hacerlo utilizando el operador NOT. <br><br> El operador NOT es justo lo que dice, NO esos bits. Aquí hay una tabla de verdad para NO. <br><br><p class="code">~00 = 11<br>
~01 = 10<br>
~10 = 01<br>
~11 = 00<br><span class="notranslate"></span></p><br> Este operador hace que la eliminación de indicadores sea muy simple, y mejor aún, generalmente es una optimización de tiempo de compilación, lo que significa que si estás usando un número constante (es decir, no una variable), el compilador mostrará los bits automáticamente. Tomemos esta declaración donde queremos borrar los bits 1 y 3 nuevamente: <br><br><p class="code">a = a &amp; ~5;<br><span class="notranslate"></span></p><br> Esto se compilará hasta &quot;a &amp; 11111111111111111111111111111010&quot;. Esto hace que la vida sea bastante simple en términos de banderas de limpieza. <br><br> El último operador que queremos ver es EOR (O exclusivo, a veces llamado XOR), este operador invierte los bits establecidos en <i>ambos</i> valores. Aquí está la tabla de verdad de EOR: <br><br><p class="code">0 ^ 0 = 0<br>
0 ^ 1 = 1<br>
1 ^ 0 = 1<br>
1 ^ 1 = 0<br><span class="notranslate"></span></p><br> Es curioso, pero increíblemente útil. Por ejemplo, digamos que queremos un contador que simplemente cuenta de 0 a 1 y de nuevo a 0 (alternar entre 0 y 1), podríamos agregar uno y hacer un IF para ver si se ha llegado a 2, y luego reiniciarlo de nuevo a 1. O... podríamos agregar 1 y luego AND con 1 (desde 01 + 01 = 10, y 10 &amp; 01 = 0) o podemos hacer esto: <br><br><p class="code">a = a ^ 1;<br><span class="notranslate"></span></p><br> Lo que hace, la primera vez es 0 ^ 1 = 1, luego la segunda vez 1 ^ 1 = 0, alternando las cosas de 0 a 1. <br><br> Entonces - O (|), Y (&amp;), NO (~) y EOR (^) manipulemos los bits con relativa facilidad, permitiéndonos, en el nivel más simple, controlar múltiples bits a la vez. Obviamente podemos usar estas operaciones para otras cosas cuando desarrollamos nuestros juegos, como enmascarar sprites, hacer operaciones MOD enteras (usando AND) o hacer buenos contadores de bucle. </div><br> <label class="collapse" for="three">Aritmética binaria simple</label> <input id="three" type="checkbox"><div class="index_list"> ¿Cómo agrega una computadora? Bueno, veamos un ejemplo muy simple 1 + 1. <br><br><p class="code">00000001<br>
00000001<br>
00000010<br><span class="notranslate"></span></p><br> Al igual que las adiciones normales, agregamos números juntos y luego desbordamos a la siguiente columna, pero a diferencia de una suma decimal normal, solo podemos ir a 1, no a 9. Así que agregar un 1 + 1 significa que desbordamos a 10. Entonces, miremos en un ejemplo más complejo. <br><br><p class="code">01011011 = 91<br>
00101101 = 45<br>
10001000 = 136<br><span class="notranslate"></span></p><br> Obviamente, es más difícil de ver aquí, pero los desbordamientos se extienden hasta que no hay más en una columna, o 2 en cuyo punto una marca de desbordamiento hace 3 y permanece allí. Afortunadamente, nunca tendrá que preocuparse por esto a menos que quiera agregar números muy grandes (como números de 2x128 bits). También vale la pena señalar que las computadoras solo pueden agregar (o restar, multiplicar o dividir) 2 números a la vez, incluso SIMD se basa en 2 cálculos a la vez, pero haciendo múltiples cálculos en paralelo. Tome 19 + 19 + 19. Como somos humanos, podemos sumar todos los 9, llevar los 2 y luego seguir. Pero las computadoras no pueden hacer eso, lo que <i>pueden</i> hacer es esto: (19 + 19) + 19. Entonces harán cada cálculo en bloques de 2. <br><br> Los cálculos binarios que nos interesan y son de gran utilidad son la multiplicación y la división. Las computadoras solo se multiplican en 2, y para hacer más romperá un número aparte y luego sumará todos los resultados. Tomemos algunos ejemplos muy simples primero. 4 * 2 = 8. Ahora, para multiplicar por 2 en binario, cambiamos todos los bits a la IZQUIERDA por uno. Me gusta esto: <br><br><p class="code">00000100 * 2 = 00001000 = 8<span class="notranslate"></span></p><br> Todos los bits en este caso se han movido hacia la izquierda en uno, lo que lo hace pasar del 3er bit al 4to, y cambiando el valor de 4 a 8. ¿Qué tal un número mayor? <br><br><p class="code">101 = 01100101 * 2 = 11001010 = 202<span class="notranslate"></span></p><br> De nuevo, todos los bits se mueven en uno, y eso se multiplica por 2. Entonces, ¿qué tal un múltiplo por 4? Fácil, cambiamos todo lo que queda por 2, en lugar de uno. Entonces, ¿qué tal 16 o 128? Esto requeriría un desplazamiento hacia la izquierda de 4 bits, o 7 bits respectivamente. Esto es increíblemente útil; significa que podemos hacer multiplicaciones simples simplemente moviendo bits. Para hacer esto, usamos el operador SHIFT &lt;&lt;. Aquí hay unos ejemplos: <br><br><p class="code">00000001 &lt;&lt; 1 = 000000010 = 2<br>
00000001 &lt;&lt; 2 = 000000100 = 4<br>
00000001 &lt;&lt; 3 = 000001000 = 8<br>
00000001 &lt;&lt; 4 = 000010000 = 16<br>
00000001 &lt;&lt; 5 = 000100000 = 32<br>
00000001 &lt;&lt; 6 = 001000000 = 64<br>
00000001 &lt;&lt; 7 = 010000000 = 128<br>
00000001 &lt;&lt; 8 = 100000000 = 256<br><span class="notranslate"></span></p><br> Ahora, además de ser muy útil para multiplicaciones rápidas / simples, también es muy útil para establecer TBI específicos, sin tener que calcular el valor del bit. Digamos que queríamos configurar el bit 27, ¿qué número es eso? (67108864 por cierto!), Bueno, podemos usar la sintaxis anterior para establecer fácilmente indicadores como este: <br><br><p class="code">A = A | (1&lt;&lt;27)<br><span class="notranslate"></span></p><br> De acuerdo... así que en realidad esto sería un poco 26 de la forma en que he estado describiendo las cosas hasta ahora (ya que los bits han comenzado en uno), pero en realidad... los bits comienzan en el bit 0 y van hacia arriba, no en el bit 1 Así que, aunque hay 32 bits en INTEGER, los bits van del 0 al 31, no del 1 al 32. En realidad, esto es bastante útil, ya que ahora podemos configurar CONSTANTES para los números de los bits. <br><br> Entonces, digamos que el Bit 27 es un indicador activo, y el bit 0 es un indicador que explota. ¿Cómo podemos establecer ambos? <br><br><p class="code">ACTIVE= 27;<br>
BOOM = 0;<br>
A = A | (1&lt;&lt;ACTIVE) | (1&lt;&lt;BOOM);<br><span class="notranslate"></span></p><br> Esto puede parecer mucho código, pero si estos números son constantes, el compilador compilará previamente estas operaciones en un solo valor para que terminemos con esto como código real. <br><br><p class="code">A = A | 13421772;<br><span class="notranslate"></span></p><br> Limpiar estos bits (como vimos anteriormente) es simplemente una cuestión de usar el modificador NOT, como este: <br><br><p class="code">A = A &amp; ~((1&lt;&lt;ACTIVE) |
(1&lt;&lt;BOOM));<br><span class="notranslate"></span></p><br> Así que esto nos permite establecer y borrar cualquier fragmento que nos gustaría, y también nos permite comprimir las estructuras de datos masivamente. La compresión de estructuras de datos es algo bueno, porque si usa menos memoria, obtendrá menos errores de caché y su código solo se ejecutará más rápido. Ponlo de esta manera, ¿qué es más rápido, copiando 32Mbytes o datos, o 4Mbytes? Bueno, bastante claro 4 es. Entonces, si puedes agrupar todas tus banderas en un solo acceso a la memoria, ¡esto es bueno! </div><br> <label class="collapse" for="four">División binaria</label> <input id="four" type="checkbox"><div class="index_list"> Echemos un vistazo rápido a cómo se divide y por qué va a ser tan útil. Tomemos un número simple - 64 - y divida por 32: <br><br><p class="code">64 / 32 = 01000000 &gt;&gt; 5 = 00000010<br><span class="notranslate"></span></p><br> Así que allí cambias el único bit <i>hacia abajo</i> por 5 (que es el número de cambios requeridos para 32 - mira arriba), lo que nos da 2. Pero, ¿qué sucede si aquí hay otros bits allí? Bueno, echemos un vistazo: <br><br><p class="code">68 / 32 = 01000100 &gt;&gt; 5 = 00000010<br><span class="notranslate"></span></p><br> Ahí vas…. Es exactamente lo mismo. Los bits que cambiamos se pierden simplemente. Esto es realmente útil, porque al dividirnos si necesitamos el resto, hay una forma aún más fácil de obtenerlo, lo cual abordaremos en un momento. Pero primero, tomemos un ejemplo práctico. Tengo una posición X e Y, y quiero obtener la celda de la cuadrícula, donde la cuadrícula tiene un tamaño de 32x32. Este método permite almacenar objetos, colisiones, banderas, todo tipo de cosas, y acceder a ellas muy rápidamente. Así que, aquí vamos: <br><br><p class="code">var X_index = x&gt;&gt;5;<br>
var Y_index = y&gt;&gt;5;<br>
cell_data = mygrid[# X_index,Y_index];<br><span class="notranslate"></span></p><br> Esto es rápido, muy rápido. Esto evita la necesidad de hacer una división de punto flotante, y luego un cálculo de piso (), que todo se suma. <br><br> Entonces, ¿qué pasa si queremos el resto? Quizás este resto se use como algún tipo de orden o algo, sea cual sea el motivo, obtener un residuo es tan simple como hacer un AND: <br><br><p class="code">var r = x &amp; 31<br>
var X_Index = x&gt;&gt;5;<br><span class="notranslate"></span></p><br> Ahora, las personas de agudos entre ustedes habrán notado que hemos usado las dos aquí (como suele ser el caso), pero esto sigue siendo solo un par de instrucciones. Pero, ¿por qué el 31? Bueno, como el bit 5 es 32, entonces todos los bits a continuación serían 31, y ese es el resto máximo así que eso es con lo que AND (también podríamos usar ((1 &lt;&lt; 5) -1) que haría 32-1 = 31. Ahora, si tuviera que hacer esto sin entender el binario, se vería así: <br><br><p class="code">var r = x mod 32;<br>
var X_Index = floor(x/32);<br><span class="notranslate"></span></p><br> Entonces, ¿por qué es esto mucho peor? Bueno, para dividir por 32, tenemos que ejecutar una división de punto flotante, lo que obviamente lleva tiempo, pero para hacer el mod 32, ¡en realidad tienes que hacer otro! Si hiciéramos esto en ensamblador, en realidad obtendríamos AMBOS valores en una división, pero no lo obtendríamos en lenguajes de alto nivel (bueno... no muy a menudo), por lo que tendrían que hacer todo el trabajo dos veces. Esto suma, especialmente si estás haciendo un ciclo cerrado con muchos cálculos como este. Las divisiones enteras como se muestra arriba realmente ayudan a optimizar tu juego. </div></blockquote><p><br></p><h2> Ejemplos </h2><p><br></p><p> Dado que este puede ser un concepto bastante complejo de entender y luego aplicar a situaciones de programación del mundo real, puede encontrar a continuación una serie de ejemplos breves que podrían aplicarse a cualquier juego hecho con <i><span class="notranslate">GameMaker Studio 2</span></i>. </p><blockquote> <label class="collapse" for="five">Alineación de azulejos</label> <input id="five" type="checkbox"><div class="index_list"> <i><span class="notranslate">GameMaker Studio 2</span></i> menudo usan la función <tt>place_free()</tt>, y luego, cuando se encuentra una colisión, intente mover el objeto lentamente haciendo un bucle alrededor de una posición xey (o algo así) mientras continúa ejecutando esa función, o usando el <tt>move_outside_all()</tt> función. <br><br> Entonces, ¿cuál es la forma más rápida de hacer esto? Bueno, si usamos fichas de power-of-2 adecuadas, entonces tenemos un método muy simple que también es muy rápido. Si nos movemos hacia la derecha y nos hemos movido hacia un bloque de colisión, como sabemos que todo está alineado con 32, también tenemos que alinear el sprite a un límite de 32 píxeles, preferiblemente el de la izquierda, para que el sprite se mueve FUERA de la colisión. Esto es realmente fácil, conociendo las reglas que hemos utilizado anteriormente para obtener el resto, y sabiendo cómo obtener el inverso de bits, podemos simplemente hacer esto: <br><br><p class="code">X = x&amp;~31;<br><span class="notranslate"></span></p><br> Así es, eso es TODO lo que se necesita para alinearse a un límite de 32 píxeles. Al cambiar el 31, podemos alinearnos con cualquier cosa que queramos, siempre que sea una potencia de 2. (Esto es equivalente a dividir por 32, luego multiplicar por 32, eliminando así los bits más bajos). <br><br> Si quisiéramos alinearnos a la derecha, haríamos lo anterior, pero luego sumar 32 para moverlo al siguiente mosaico. Sencillo. Todo esto hace que el código de colisión sea monumentalmente más rápido y le permite pasar el tiempo de la CPU donde realmente lo necesita. </div><br> <label class="collapse" for="six">Llaves y puertas</label> <input id=
"six" type="checkbox"><div class="index_list"> Digamos que tiene un nivel con algunas puertas y una clave para cada una. ¿Cómo se puede marcar fácilmente una tecla para una clave? Bueno, normalmente asignarías una identificación a la llave y a la puerta. Entonces, ¿qué pasa si quieres una llave para abrir 2 o 3 puertas? Fácil. Usas una MÁSCARA. La puerta tendría un único &quot;bit&quot; asignado como por ejemplo door_id = 1 (0001), otro con door_id = 2 (0010), door_id = 4 (0100), door_id = 8 (1000) y así sucesivamente. Si quisiéramos que la llave abriera la puerta 1 y 3, entonces la llave tendría la MÁSCARA de 5 (que es 101 en binario). Si realizamos un Y de esto, y sale &quot;no cero&quot;, entonces sabemos si la llave puede abrir la puerta. También podría tener claves que no abren nada al tener una MÁSCARA de 0. Consulte el código a continuación para la verificación real: <br><br><p class="code">if( (key_id &amp; door_id) !=0 ) { opendoor();
}<br><span class="notranslate"></span></p></div><br> <label class="collapse" for="seven">Contadores de bucle</label> <input id="seven" type="checkbox"><div class="index_list"> Digamos que queremos un contador de animación simple, contando de 0 a 15 (ya que tenemos 16 fotogramas de animación), ahora podemos hacer un incremento y luego hacer un IF, o podemos usar nuestro conocimiento de binario y eliminar el SI completamente Los IF son lentos, y si no los necesitamos, debemos eliminarlos. <br><br><p class="code">counter = (counter+1)&amp;31;<br><span class="notranslate"></span></p><br> Como 16 cuadros es una potencia de 2 números, y como 0 está incluido en el contador, podemos reducir el número de POW2 en 1 y usarlo como MÁSCARA, y con eso podemos usarlo para envolver nuestro contador. Si el contador se mueve de 15 a 16, terminamos con el patrón de bits 10000, y si hacemos AND con 15 (patrón de bits 01111) terminamos con 0. Esto significa que el código anterior es increíblemente útil para envolver contadores, siempre y cuando usted usa números de fotograma POW2. </div><br> <label class="collapse" for="eight">Poder de 2 Cheque</label> <input id="eight" type="checkbox"><div class="index_list"> ¿Qué pasaría si quisieras verificar si algo era un poder de 2? Bueno, aquí hay un pequeño truco... Esto devolverá TRUE si argumento0 es un poder de 2. <br><br><p class="code">return (argument0&amp;(argument0-1))==0;<br><span class="notranslate"></span></p><br> Entonces, si tuviéramos el número 51 (110011), ¿qué hace esto? Bueno, obtenemos esto... 110011 y 110010, lo que obviamente nos deja con FALSO, ya que quedan muchos &quot;bits&quot; después del AND. Si tuviéramos 64 1000000, entonces se convierte en esto... 1000000 y 0111111 lo que SÍ nos deja 0, entonces es VERDADERO. </div><br> <label class="collapse" for="nine">Alineación de índice</label> <input id="nine" type="checkbox"><div class="index_list"> Aquí hay un fragmento rápido de código para alinear a la potencia de 2 números. (1,2,4,8,16 y así sucesivamente). Esto puede ser muy útil para la asignación de memoria, o para asegurarse de escribir los datos en los límites apropiados. En este ejemplo, el argumento 0 debe alinearse con argumentos1 bytes, donde argumento1 es una potencia de 2 números. Este pequeño guión redondea hacia ARRIBA hasta el siguiente límite del número deseado. <br><br><p class="code">return (argument0 + (argument1-1)) &amp;
~(argument1-1);<br><span class="notranslate"></span></p><br></div></blockquote><p><br></p></div><div class="footer"><div class="buttons"><div class="clear"><div style="float:left"> Atrás: <a href="index.html">Índice de información adicional</a> </div><div style="float:right"> Siguiente: <a href="errors.html">Errores del compilador</a> </div></div></div><h5> © Copyright <span class="notranslate">YoYo Games Ltd.</span> 2017 Todos los derechos reservados </h5>
<script type="text/javascript">
   (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');   ga('create', 'UA-2711665-14', 'auto');   ga('send', 'pageview'); 
</script>
</div>

<script type="text/JavaScript">
var fe = FindFrame("toc", top);
if ((fe != null) && (chmtop.c2wtopf.jstree != null)) {
  if (chmtop.c2wtopf.FITEMS[chmtop.c2wtopf.pagenum] != chmtop.c2wtopf.pageid)
    chmtop.c2wtopf.jstree.OpenTreeNode("source/" + chmtop.c2wtopf.pageid);
}
</script>
</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="keywords" content="online documentation, web online help, web help, chm2web" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="generator" content="chm2web Pro 2.85 (unicode)" />
<title>Bitwise Operators And Binary</title>
<meta http-equiv="X-UA-Compatible" content="IE=9">

<link rel="stylesheet" href="../../../../files/helpindex.css" type=
"text/css">
<link rel="stylesheet" href="../../../../default.css" type=
"text/css">

<script type="text/JavaScript" src="../../../../files/supply.js"></script>
<script type="text/JavaScript">
chmtop.c2wtopf.pageid = "_build/1_overview/3_additional_information/bitwise_operators.html";
</script>

</head>
<body><script type="text/JavaScript"> 
if (window.name != "content") 
  document.write(" <table width=\"100%\" bgcolor=\"#e1e1e1\"cellspacing=\"2\" cellpadding=\"0\" style=\"border-collapse: collapse; font-family: sans-serif; font-size: 14px; color: #000000; text-decoration: none;  \"> <tr> <td align=\"center\" style=\"border-bottom: 2px solid gray\" > <br>&nbsp;Click <a href=\"../../../../index.html?page=source%2F_build%2F1_overview%2F3_additional_information%2Fbitwise_operators.html\">here</a> to show toolbars of the Web Online Help System: <a href=\"../../../../index.html?page=source%2F_build%2F1_overview%2F3_additional_information%2Fbitwise_operators.html\">show toolbars</a><br>&nbsp;</td></tr></table><br> "); 
</script>
<!-- !chm2web! --><script type="text/JavaScript">
 if( typeof(chmtop.helpStyle) != 'undefined' ) { var linkNodes = document.getElementsByTagName("link");  for( var i=0; i < linkNodes.length; ++i ) { var link = linkNodes[i];    if( link.href.endsWith("default.css")) {    var style = link.href.replace("default.css", chmtop.helpStyle); document.write('<link id="newstyleLink" rel="stylesheet" href=' + style + ' type="text/css">');    break; } } } 
</script><h2> Operadores Bitwise Y Binarios </h2><div class="body-scroll"><p><br></p><p> Al comienzo de la era de la computadora, binario y hex (hexadecimal) eran una forma de vida, probablemente porque los lenguajes de alto nivel (como el BASIC) eran simplemente demasiado lentos. Sin embargo, en estos días, con la potencia de la PC más promedio, ya no tiene que saber nada de esto y puede hacer las cosas a largo plazo, ya que la velocidad de la máquina y su construcción de CPU más compleja compensarán cualquier corto viene este enfoque tiene. </p><p> Como un ejemplo muy simple, en el pasado, multiplicar por 32 podría haber tomado varios ciclos de CPU para ejecutarse, mientras que una simple operación binaria para hacer lo mismo habría tomado solo 1. A medida que las máquinas se han vuelto más complejas, también han reducido el tiempo. muchas instrucciones complejas se ejecutan de modo que ahora, una multiplicación de 32x32 bits podría tomar solo 1 ciclo, igual que el operador binario. Esta es una gran noticia, por supuesto, ya que significa que ya no tiene que optimizar cada línea de código que escribe, pero si este es el caso, ¿debería realmente preocuparse por el binario? </p><p> La respuesta es definitivamente &quot;sí, deberías&quot;. Si bien es cierto, aún puede obtener algunos incrementos de velocidad, y en ocasiones esto puede ser significativo. El uso de binarios y hexadecimales le permite conocer mejor la CPU y también puede llevar a escribir mejor código, poder empaquetar mejor los datos y realizar algunas tareas. mucho mas simple Esta página explicará un poco sobre qué es el binario y cómo se puede usar al crear tus juegos. </p><blockquote> <label class="collapse" for="one">Teoría de los números</label> <input id="one" type="checkbox"><div class="index_list"> Veamos primero la teoría binaria más básica: cómo se crean los números. Echa un vistazo a esta tabla: <br><br><p class="code">000 = 0<br>
001 = 1<br>
010 = 2<br>
100 = 4<br><span class="notranslate"></span></p><br> Cada 1 o 0 representa un solo <i>bit</i> de datos, y como puede ver, esto significa que en binario, 10 es igual a 2! Cada bit es <i>2 veces el valor anterior</i> y el primer bit es igual a 1. Así que el bit 2 = 2, el bit 3 = 4, el bit 4 = 8 y así sucesivamente (como se muestra a continuación en esta tabla de <i>bytes</i>, un byte es una colección de 8 bits): <br><br><p class="code">00000001 = 1<br>
00000010 = 2<br>
00000100 = 4<br>
00001000 = 8<br>
00010000 = 16<br>
00100000 = 32<br>
01000000 = 64<br>
10000000 = 128<br><span class="notranslate"></span></p><br> Está bien si quieres números con una potencia de 2, pero ¿cómo creamos números más complejos? Bueno, un solo número binario solo puede almacenar un 0 o 1, y eso es todo, por lo que para números más complejos necesitamos sumar bits. Si por ejemplo quisiéramos hacer 6, sumaríamos 4 y 2 juntos como tal. <br><br><p class="code">00000010 = 2<br>
00000100 = 4<br>
00000110 = 6<br><span class="notranslate"></span></p><br> Esto es cierto para <i>todos</i> los números binarios, y cómo la computadora inventa cualquier número internamente. Tomemos un número un poco más complicado como otro ejemplo: 23. El número 23 en realidad está formado por 1 + 2 + 4 + 16 o 00010111. ¿Qué tal un ejemplo mucho más complejo: 196? Bueno, eso está hecho de 128 + 64 + 4 o 11000100. Así que en realidad no es tan complejo. Si comenzamos a hacer valores fuera del rango de un byte (que puede almacenar números de 0 a 255), comienza a ser un poco más difícil de rastrear. Por ejemplo, 217,361 es 110101000100010001 en binario. O, 1 + 16 + 256 + etc... Las reglas son las mismas, independientemente del valor que se exprese, cada número se crea a partir de la adición de varios bits. </div><br> <label class="collapse" for="two">Operadores Binarios</label> <input id="two" type="checkbox"><div class="index_list"> Ahora, ¿qué significa esto en binario? Bueno, digamos que quieres guardar un <tt>true</tt> o <tt>false</tt> como un valor. Por lo general, los compiladores utilizarán un INT (un INT se define generalmente como un número de 32 bits con signo) y luego lo asignarán a 0 o 1. Sin embargo, al tener solo 2 estados, un <tt>true</tt> / <tt>false</tt> El valor es ideal para almacenar en un momento, y si hiciéramos esto podríamos almacenar 32 <tt>true</tt> / <tt>false</tt> bits para cada INT en lugar de solo uno. <br><br> ¿Cómo haríamos esto? Bien bastante fácilmente resulta: <br><br><p class="code">flags = flags | 1;<br><span class="notranslate"></span></p><br> El &quot;|&quot; operador es un <b>OR a nivel de bit</b>, y esto significa que la instrucción anterior ORs 1 se convierte en indicadores. Si recuerda de antes, usar un 1 establecerá el primer bit. Si quisiéramos establecer el segundo bit, haríamos esto: <br><br><p class="code">flags = flags | 2;<br><span class="notranslate"></span></p><br> Nosotros O en 2, porque el patrón de bits 00000010 es igual a 2. Entonces, ¿qué hace exactamente el operador binario OR? Bueno, combina todos los bits en un solo valor, como este: <br><br><p class="code">010110100<br>
110011001<br>
110111101<br><span class="notranslate"></span></p><p><br> Esto es lo que se conoce como una <i>tabla de verdad</i> para el operador OR: <br><br></p><p class="code">00 | 00 = 00<br>
00 | 01 = 01<br>
01 | 01 = 01<br>
01 | 00 = 01<br><span class="notranslate"></span></p><br> Entonces, donde hay un valor con 2 ceros, permanecerá en cero. La ventaja de usar BITS como un estado verdadero / falso, es que puede establecer varios indicadores en una operación, algo que simplemente no podría hacer con un valor booleano normal. Por ejemplo, digamos que el bit 1 es un indicador &quot;activo&quot;, y el bit 3 es un indicador &quot;visible&quot;. Podríamos establecer <i>ambos</i> haciendo esto: <br><br><p class="code">flags = flags | 5;<br><span class="notranslate"></span></p><br> Esto se debe a que 5 es 00000101 en binario, y siguiendo la regla anterior, las variables &quot;flags&quot; obtendrán estos dos bits combinados con los suyos. Entonces, incluso si el bit 1 ya estaba establecido, la operación aún funciona y el bit 3 ahora también se configurará. <br><br> ¿Qué hay de borrar banderas? Bueno, aquí es donde entra en juego la operación AND binaria. Cuando usted Y algo, se guardan los bits que están establecidos en la máscara, mientras que los bits que están claros en la máscara, se eliminan, como esto: <br><br><p class="code">01110010101<br>
00110000100<br>
00110000100<br><span class="notranslate"></span></p><br> Como puede ver, donde hay un bit en cada valor, el bit se mantiene, y donde hay una mezcla o 0 y 1, estos se restablecen a 0. Aquí está la tabla de verdad para ANDing: <br><br><p class="code">00 &amp; 00 = 00<br>
01 &amp; 00 = 00<br>
00 &amp; 01 = 00<br>
01 &amp; 01 = 01<br><span class="notranslate"></span></p><p><br> Entonces, solo cuando haya un poco en cada lugar se mantendrá. Lo que esto significa es que, al igual que puede <i>configurar</i> varios indicadores a la vez, también puede <i>borrar</i> varios indicadores a la vez. Por ejemplo, tomemos el caso anterior, pero esta vez elimínelos. Queremos borrar los bits 1 y 3 (dándonos el valor 5), pero al recordar la tabla de verdad anterior, lo que queremos hacer es mantener todos los otros bits y borrar los bits 1 y 3. Esto sería una máscara binaria &quot; &quot;de 11111111111111111111111111111010 (32 bits). Esta máscara mantiene todos los bits establecidos actualmente, pero borra los dos bits que realmente queremos borrar. Entonces, si tuviera un valor de 1000111011 y quisiera borrar los bits 1 y 3 usando la máscara de arriba, terminaría con esto... <br><br></p><p class="code">00000000000000000000001000111011<br>
11111111111111111111111111111010<br>
00000000000000000000001000111010<br><span class="notranslate"></span></p><br> Esto es genial, pero si tuviéramos que resolverlo cada vez que tuviéramos que limpiar las banderas, se volvería agotador. Lo que necesitamos es una forma de voltear bits fácilmente (y preferiblemente sin costo de CPU). Afortunadamente, hay una forma fácil de hacerlo utilizando el operador NO. <br><br> El operador NO es justo lo que dice, NO esos bits. Aquí hay una tabla de verdad para NO. <br><br><p class="code">~00 = 11<br>
~01 = 10<br>
~10 = 01<br>
~11 = 00<br><span class="notranslate"></span></p><br> Este operador hace que la eliminación de indicadores sea muy simple, y aún mejor, generalmente es una optimización de tiempo de compilación, lo que significa que si está utilizando un número constante (es decir, no una variable), el compilador cambiará los bits automáticamente por usted. Tome esta declaración donde queremos borrar los bits 1 y 3 de nuevo: <br><br><p class="code">a = a &amp; ~5;<br><span class="notranslate"></span></p><br> Esto realmente se compilará hasta &quot;a &amp; 11111111111111111111111111111010&quot;. Esto hace que la vida sea bastante simple en términos de borrar banderas. <br><br> El último operador que queremos ver es EOR (OR exclusivo, a veces llamado XOR), este operador invierte los bits establecidos en <i>ambos</i> valores. Aquí está la tabla de verdad de EOR: <br><br><p class="code">0 ^ 0 = 0<br>
0 ^ 1 = 1<br>
1 ^ 0 = 1<br>
1 ^ 1 = 0<br><span class="notranslate"></span></p><br> Esta es una curiosa, pero increíblemente útil. Por ejemplo, digamos que queremos un contador que simplemente cuenta de 0 a 1 y vuelve a 0 (alterna entre 0 y 1), podemos agregar uno y hacer un IF para ver si se ha puesto a 2, y luego restablecerlo a 1. O... podríamos agregar 1 y luego Y con 1 (ya que 01 + 01 = 10, y 10 &amp; 01 = 0) o podemos hacer esto: <br><br><p class="code">a = a ^ 1;<br><span class="notranslate"></span></p><br> Lo que esto hace, es que la primera vez que pasa es 0 ^ 1 = 1, luego la segunda vez 1 ^ 1 = 0, por lo que las cosas cambian de 0 a 1. <br><br> Así que - OR (|), AND (&amp;), NOT (~) y EOR (^) nos permiten manipular los bits con relativa facilidad, permitiéndonos, en el nivel más simple, controlar múltiples bits a la vez. Obviamente, podemos usar estas operaciones para otras cosas al desarrollar nuestros juegos, como enmascarar sprites, realizar operaciones MOD de enteros (usando AND) o hacer bonitos contadores de bucle. </div><br> <label class="collapse" for="three">Aritmética binaria simple</label> <input id="three" type="checkbox"><div class="index_list"> ¿Cómo se agrega una computadora? Bueno, veamos un ejemplo muy simple 1 + 1. <br><br><p class="code">00000001<br>
00000001<br>
00000010<br><span class="notranslate"></span></p><br> Al igual que las adiciones normales, sumamos números y luego nos desbordamos a la siguiente columna, pero a diferencia de una suma decimal normal, solo podemos ir a 1, no a 9. Entonces, al agregar un 1 + 1 significa que desbordamos a 10. Entonces, veamos en un ejemplo más complejo. <br><br><p class="code">01011011 = 91<br>
00101101 = 45<br>
10001000 = 136<br><span class="notranslate"></span></p><br> Obviamente, es más difícil de ver aquí, pero los desbordamientos se extienden hasta que no hay uno en una columna, o 2, punto en el que un bit de desbordamiento genera 3 y permanece allí. Afortunadamente, nunca tendrá que preocuparse por esto a menos que desee sumar números muy grandes (como los números de 2x128 bits). También vale la pena señalar que las computadoras solo pueden sumar (o restar, multiplicar o dividir) 2 números a la vez, incluso SIMD se basa en 2 cálculos a la vez, pero haciendo cálculos múltiples en paralelo. Toma 19 + 19 + 19. Siendo humanos, podemos sumar todos los 9 juntos, llevar el 2 y luego ¡vamos! Pero las computadoras no pueden hacer eso, lo que <i>pueden</i> hacer es esto: (19 + 19) + 19. Así que harán cada cálculo en bloques de 2. <br><br> Los cálculos binarios que son de interés para nosotros, y de gran utilidad, son la multiplicación y la división. Las computadoras solo se multiplican en 2, y para hacer más se dividirá un número y luego se sumarán todos los resultados. Tomemos algunos ejemplos muy simples primero. 4 * 2 = 8. Ahora, para multiplicar por 2 en binario, cambiamos todos los bits a la IZQUIERDA en uno. Me gusta esto: <br><br><p class="code">00000100 * 2 = 00001000 = 8<span class="notranslate"></span></p><br> Todos los bits en este caso se han movido hacia la izquierda en uno, haciéndolo moverse desde el tercer bit al cuarto y cambiando el valor de 4 a 8. ¿Qué tal un número mayor? <br><br><p class="code">101 = 01100101 * 2 = 11001010 = 202<span class="notranslate"></span></p><br> Una vez más, todos los bits se mueven en uno, y eso se multiplica por 2. Entonces, ¿qué tal un múltiplo por 4? Fácil, cambiamos todo lo que queda por 2, en lugar de uno. Entonces, ¿qué hay de 16 o 128? Esto requeriría un desplazamiento a la izquierda de 4 bits, o 7 bits respectivamente. Esto es increíblemente útil; significa que podemos hacer multiplicaciones simples simplemente moviendo bits alrededor. Para ello, utilizamos el operador SHIFT &lt;&lt;. Aquí hay unos ejemplos: <br><br><p class="code">00000001 &lt;&lt; 1 = 000000010 = 2<br>
00000001 &lt;&lt; 2 = 000000100 = 4<br>
00000001 &lt;&lt; 3 = 000001000 = 8<br>
00000001 &lt;&lt; 4 = 000010000 = 16<br>
00000001 &lt;&lt; 5 = 000100000 = 32<br>
00000001 &lt;&lt; 6 = 001000000 = 64<br>
00000001 &lt;&lt; 7 = 010000000 = 128<br>
00000001 &lt;&lt; 8 = 100000000 = 256<br><span class="notranslate"></span></p><br> Ahora, además de ser muy útil para multiplicaciones rápidas / simples, también es muy útil para establecer BIT específicos, sin tener que averiguar el valor del bit. Digamos que queríamos establecer el bit 27, ¿qué número es ese? (67108864 por cierto!), Bien, podemos usar la sintaxis de arriba para establecer fácilmente indicadores como este: <br><br><p class="code">A = A | (1&lt;&lt;27)<br><span class="notranslate"></span></p><br> Bueno... en realidad esto sería el bit 26 de la forma en que he estado describiendo las cosas hasta ahora (ya que los bits han empezado en uno), pero en realidad... los bits comienzan en el bit 0 y van hacia arriba, no en el bit 1 Entonces, mientras hay 32 bits en un INTEGER, los bits varían de 0 a 31, no de 1 a 32. Esto es realmente muy útil, ya que ahora podemos configurar CONSTANTES para los números de bits. <br><br> Así que digamos que el Bit 27 es un indicador activo, y el bit 0 es un indicador de explosión. ¿Cómo podemos configurar ambos? <br><br><p class="code">ACTIVE= 27;<br>
BOOM = 0;<br>
A = A | (1&lt;&lt;ACTIVE) | (1&lt;&lt;BOOM);<br><span class="notranslate"></span></p><br> Esto puede parecer una gran cantidad de código, pero si estos números son constantes, el compilador precompilará estas operaciones en un solo valor para que terminemos con esto como código real. <br><br><p class="code">A = A | 13421772;<br><span class="notranslate"></span></p><br> Borrar estos bits (como vimos anteriormente) es simplemente una cuestión de usar el modificador NOT, como esto: <br><br><p class="code">A = A &amp; ~((1&lt;&lt;ACTIVE) |
(1&lt;&lt;BOOM));<br><span class="notranslate"></span></p><br> Así que esto nos permite establecer y borrar los bits que deseamos, y también nos permite comprimir las estructuras de datos de forma masiva. Comprimir las estructuras de datos es una buena cosa, porque si usa menos memoria, obtendrá menos errores de caché y su código simplemente se ejecutará más rápido. Dicho de esta manera, ¿qué es más rápido, copiar 32Mbytes o datos, o 4Mbytes? Bueno, claramente 4 es. Entonces, si puede empaquetar todas sus banderas en un solo acceso de memoria, ¡esto es bueno! </div><br> <label class="collapse" for="four">División binaria</label> <input id="four" type="checkbox"><div class="index_list"> Echemos un vistazo rápido a cómo haces la división y por qué será tan útil. Tomemos un número simple - 64 - y dividamos por 32: <br><br><p class="code">64 / 32 = 01000000 &gt;&gt; 5 = 00000010<br><span class="notranslate"></span></p><br> Entonces, hay que desplazar el bit único <i>hacia abajo</i> en 5 (que es el número de turnos requeridos para 32 - mira arriba), lo que nos da 2. Pero, ¿qué sucede si hay otros bits allí? Bueno, vamos a echar un vistazo: <br><br><p class="code">68 / 32 = 01000100 &gt;&gt; 5 = 00000010<br><span class="notranslate"></span></p><br> Ahí vas…. Es exactamente lo mismo. Los bits que cambiamos hacia abajo simplemente se pierden. Esto es realmente útil, porque al dividirnos si necesitamos el resto, hay una manera aún más fácil de obtenerlo, lo cual haremos en un momento. Pero primero, tomemos un ejemplo práctico. Tengo una posición X e Y, y quiero obtener la celda de la cuadrícula en la que se encuentra, donde la cuadrícula es de 32x32 de tamaño. Este método permite almacenar objetos, colisiones, banderas, todo tipo de cosas, y acceder a ellos muy rápidamente. Así que, aquí vamos: <br><br><p class="code">var X_index = x&gt;&gt;5;<br>
var Y_index = y&gt;&gt;5;<br>
cell_data = mygrid[# X_index,Y_index];<br><span class="notranslate"></span></p><br> Esto es rápido, muy rápido. Esto evita la necesidad de hacer una división de punto flotante y luego un cálculo de piso (), que se suma. <br><br> Entonces, ¿y si quisiéramos el resto? Quizás este resto se use como algún tipo de orden o algo, cualquiera que sea la razón, obtener un resto es tan simple como hacer un AND: <br><br><p class="code">var r = x &amp; 31<br>
var X_Index = x&gt;&gt;5;<br><span class="notranslate"></span></p><br> Ahora, los agudos entre ustedes pueden haber notado que hemos usado ambos aquí (como suele ser el caso), pero esto es solo un par de instrucciones. Pero ¿por qué el 31? Bueno, como el bit 5 es 32, entonces todos los bits siguientes serían 31, y ese es el resto máximo, así que eso es lo que nosotros Y con (también podríamos usar ((1 &lt;&lt; 5) -1) que haría que 32-1 = 31. Ahora, si tuviera que hacer esto sin entender el binario, se vería así: <br><br><p class="code">var r = x mod 32;<br>
var X_Index = floor(x/32);<br><span class="notranslate"></span></p><br> Entonces, ¿por qué es esto mucho peor? Bueno, para poder dividir por 32, tenemos que ejecutar una división de punto flotante, lo que obviamente toma tiempo, pero para hacer el mod 32, ¡tienes que hacer otro! Si estuviéramos haciendo esto en ensamblador, en realidad obtendremos AMBOS valores en una división, pero no lo obtendremos en lenguajes de alto nivel (bueno... no muy a menudo), por lo que tiene que hacer todo el trabajo dos veces. Esto se suma, especialmente si está haciendo un circuito cerrado con muchos cálculos como este. Las divisiones de enteros como se muestra arriba realmente ayudan a optimizar tu juego. </div></blockquote><p><br></p><h2> Ejemplos </h2><p><br></p><p> Dado que este puede ser un concepto bastante complejo de comprender y luego aplicar a situaciones de programación del mundo real, a continuación puede encontrar una serie de ejemplos breves que podrían aplicarse a cualquier juego creado con <i><span class="notranslate">GameMaker Studio 2</span></i>. </p><blockquote> <label class="collapse" for="five">Alineación de azulejos</label> <input id="five" type="checkbox"><div class="index_list"> <i><span class="notranslate">GameMaker Studio 2</span></i> menudo usan la función <tt>place_free()</tt>, y luego, cuando se encuentra una colisión, intente mover lentamente el objeto hacia afuera haciendo un bucle alrededor de una posición x o y (o algo así) mientras continúa ejecutando esa función, o usando la función <tt>move_outside_all()</tt> función. <br><br> Entonces, ¿cuál es la forma más rápida de hacer esto? Bueno, si usamos las fichas de potencia de 2 adecuadas, entonces tenemos un método muy simple que también es muy rápido. Si nos estamos moviendo hacia la derecha, y nos hemos movido hacia un bloque de colisión, entonces, como sabemos, todo está alineado a 32, entonces también debemos alinear el sprite con un límite de 32 píxeles, preferiblemente el de la izquierda, para que el sprite Se mueve fuera de la colisión. Esto es realmente fácil, conociendo las reglas que hemos usado anteriormente para obtener el resto y sabiendo cómo obtener la inversa de los bits, simplemente podemos hacer esto: <br><br><p class="code">x = x&amp;~31;<br><span class="notranslate"></span></p><br> Así es, eso es TODO lo que se necesita para alinearse con un límite de 32 píxeles. Al cambiar el 31 podemos alinearnos a lo que queramos, siempre que sea una potencia de 2. (Esto es el equivalente de dividir por 32, luego multiplicar por 32, eliminando así los bits más bajos). <br><br> Si quisiéramos alinearnos a la derecha, haríamos lo anterior, pero luego agregaríamos 32 para moverlo a la siguiente casilla. Sencillo. Todo esto hace que todo el código de colisión sea monumentalmente más rápido y le permite pasar el tiempo de CPU donde realmente lo necesita. </div><br> <label class="collapse" for="six">Llaves y puertas</label> <input id=
"six" type="checkbox"><div class="index_list"> Digamos que tienes un nivel con algunas puertas y una clave para cada una. ¿Cómo se puede marcar fácilmente una clave para una clave? Bueno, normalmente solo asignas una identificación a la llave y la puerta. Entonces, ¿qué pasa si quieres una llave para abrir 2 o 3 puertas? Fácil. Usted utiliza una máscara. La puerta tendría un solo &quot;bit&quot; asignado como door_id = 1 (0001), otro con door_id = 2 (0010), door_id = 4 (0100), door_id = 8 (1000) y así sucesivamente. Si quisiéramos que la llave abriera las puertas 1 y 3, entonces la llave tendría la MÁSCARA de 5 (que es 101 en binario). Si realizamos un AND de esto, y sale &quot;no cero&quot;, entonces sabemos si la llave puede abrir la puerta. También puede tener llaves que no se abren nada al tener una MÁSCARA de 0. Consulte el código a continuación para ver la comprobación real: <br><br><p class="code">if( (key_id &amp; door_id) !=0 ) { opendoor();
}<br><span class="notranslate"></span></p></div><br> <label class="collapse" for="seven">Contadores de bucle</label> <input id="seven" type="checkbox"><div class="index_list"> Digamos que queremos un contador de animación simple, contando de 0 a 15 (ya que tenemos 16 cuadros de animación), ahora podemos hacer un incremento y luego hacer un IF, o podemos usar nuestro conocimiento de binarios y eliminar el SI completamente. Los IF son lentos, y si no los necesitamos, debemos eliminarlos. <br><br><p class="code">counter = (counter+1)&amp;15;<br><span class="notranslate"></span></p><br> Como 16 fotogramas es una potencia de 2 números, y como 0 se incluye en el contador, podemos reducir el número POW2 en 1 y usarlo como MASCARA, y usarlo para envolver nuestro contador. Si el contador se mueve de 15 a 16, terminamos con el patrón de bits 10000, y si luego Y con 15 (patrón de bits 01111) terminamos con 0. Esto significa que el código anterior es increíblemente útil para ajustar contadores, siempre que utiliza números de marco POW2. </div><br> <label class="collapse" for="eight">Potencia de 2 cheques</label> <input id="eight" type="checkbox"><div class="index_list"> ¿Qué pasaría si quisieras comprobar si algo era una potencia de 2? Bueno, aquí hay un pequeño truco. Esto devolverá VERDADERO si argumento0 es una potencia de 2. <br><br><p class="code">return (argument0&amp;(argument0-1))==0;<br><span class="notranslate"></span></p><br> Entonces, si tuviéramos el número 51 (110011), ¿qué hace esto? Bueno, conseguimos esto... 110011 y 110010, lo que obviamente nos deja con FALSO, ya que quedan muchos &quot;bits&quot; después del AND. Si tuviéramos 64 1000000, entonces se convierte en este... 1000000 y 0111111, lo que nos deja en 0, por lo que es VERDADERO. </div><br> <label class="collapse" for="nine">Alineación del índice</label> <input id="nine" type="checkbox"><div class="index_list"> Aquí hay un poco de código para alinearse con la potencia de 2 números. (1,2,4,8,16 y así sucesivamente). Esto puede ser muy útil para la asignación de memoria, o asegurarse de escribir datos en los límites adecuados. En este ejemplo, argumento0 debe alinearse a argumento1 bytes, donde argumento1 es una potencia de 2 números. Este pequeño script se redondea hasta el siguiente límite del número deseado. <br><br><p class="code">return (argument0 + (argument1-1)) &amp;
~(argument1-1);<br><span class="notranslate"></span></p><br></div></blockquote><p><br></p></div><div class="footer"><div class="buttons"><div class="clear"><div style="float:left"> Atrás: <a href="index.html">Indice de Información Adicional</a> </div><div style="float:right"> Siguiente: <a href="errors.html">Errores del compilador</a> </div></div></div><h5>© Copyright YoYo Games Ltd. 2018 All Rights Reserved</h5>
<script type="text/javascript">
   (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){   (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),   m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)   })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');   ga('create', 'UA-2711665-14', 'auto');   ga('send', 'pageview'); 
</script>
</div>

<script type="text/JavaScript">
var fe = FindFrame("toc", top);
if ((fe != null) && (chmtop.c2wtopf.jstree != null)) {
  if (chmtop.c2wtopf.FITEMS[chmtop.c2wtopf.pagenum] != chmtop.c2wtopf.pageid)
    chmtop.c2wtopf.jstree.OpenTreeNode("source/" + chmtop.c2wtopf.pageid);
}
</script>
</body>
</html>
